<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚õ≥Ô∏èüèåÔ∏è‚Äç‚ôÇÔ∏èüìù</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 20px; /* Ensuring padding for all sides */
      box-sizing: border-box;
      background-color: #ADD8E6;
      font-size: 1.2em;  /* Set a base font size */
      line-height: 1.5em; /* Improve readability */
      scroll-behavior: smooth;
    }


    h1 {
      font-size: 2.2em;
      /* Adjust the size as needed */
      margin-top: 0;
      /* Ensure no margin at the top */
    }

    h2 {
      color: blue;
      font-weight: bold;
      font-style: italic;
      padding-left: 0.25in; /* Adds 1/2 inch padding on the left */
      text-align: left; /* Aligns text to the left */
      font-size: 1.4em; /* Adjust base font size */
    }


    #title {
      font-size: 1em;
      color: blue;
      font-weight: bold;
      margin-bottom: 20px;
    }


    #instructions {
    margin: 1em 0; /* Adding margin to the top and bottom */
    font-size: 1.3em; /* Set font size to 1.6em */
    }

    /* Sticky header class -- keeps names at top when scrolling down */
    .sticky-header {
      position: sticky;
      top: 0; /* Sticky position at the top */
      background-color: #ADD8E6;   /* Background color to distinguish header */
      z-index: 1000; /* Ensure it's on top of other content */
      font-size: 1.5em; /* Set font size */
      font-weight: bold;   /* Set font weight */
    }
   
    iframe {
      width: 100%;  /* Full width */
      height: 1200px;  /* Set height */
      border: none;
      display: block;
      overflow: auto;
    }

    /* Styling for the refresh and scoreboard buttons */
    #refresh-btn,
    #scoreboard_button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      background-color: green;
      color: white;
      border: none;
      cursor: pointer;
    }

    #refresh-btn:hover,
    #scoreboard_button:hover {
      background-color: darkgreen;
    }

    button.loading {
      position: relative;
      opacity: 0.6;
      pointer-events: none;
    }

    button.loading::after {
      content: "";
      position: absolute;
      right: 10px;
      top: 50%;
      width: 18px;
      height: 18px;
      margin-top: -9px;
      border: 3px solid #fff;
      border-top: 3px solid #333;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .image-container {
        display: flex;
        justify-content: flex-start;
        margin-left: 3%; /* the margin to 3% from the left */
        gap: 30px; /* gap between the images as needed */
    }
    .image-container img {
       width: 200px; /* Set the desired width for both images */
        height: auto; /* Maintain aspect ratio */
    }


  </style>

</head>


<body>

  <audio id="audio" src="https://www.dropbox.com/scl/fi/666kzmgv2f3t6c1alhx1g/startup-sound.mp3?rlkey=isnzy1syfswgg5p3n2gskz1zp&st=5ryggmm7&raw=1" type="audio/mpeg"></audio>


    <div class="image-container">
        <img src="https://live.staticflickr.com/65535/54259105499_43c986c7ea_z.jpg" alt="GoogleGolf Scoring System Logo">
        <img src="https://live.staticflickr.com/65535/54033042787_0126e057cd_w_d.jpg" alt="BT Logo">
    </div>

<br>

  <!-- yes, the below spacing is not eloquent-- but found necessary to keep all parts aligned -- especially the Delete Player boxes -->

  <div id="title">
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Your Google-Based DIY Golf Group <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scoring System<br> 
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>V. 6.4</b><br>
  </div>

  <div id="course" style="display: inline-block; font-size: 1.75em; font-weight: bold;"></div>

  <div id="all_input">
    <div>
        <div style="display: inline-block; font-size: 1.75em; font-weight: bold;">Date: </div>
        <div style="display: inline-block; font-size: 1.75em; font-weight: bold;" id="date"></div>
    </div>
    </div>
    <div>
        <div style="display: inline-block; font-size: 1.75em;">
            <font color="Blue"><b>Tee Time: </b></font>
            <select style="display: inline-block; font-size: 1em; padding: 5px 5px; width: 8ch" id="team" placeholder= "Select">
                <option value="" disabled selected>Select</option>
            </select>
        </div>
    </div>
    <div id="team_options"></div>
    <div style="display: inline-block; font-size: 1.75em;"><b>Team Target Points =  </b></div>
    <div style="display: inline-block; font-size: 1.75em; font-weight: bold;" id="team_target"></div>
</div> 


<br>
<div id="table"></div>
<div id="buttons">
<table>
    <tr></tr>
    <tr></tr>
    <tr></tr>

    <!-- Scoreboard Use Only Button (now dark green) -->
    <tr>
        <td>
        <button id="scoreboard_button" onclick="scoreboardOnly()">
            Scoreboard Use Only
        </button>
        </td>
    </tr>

    <!-- Spacer rows (same vertical space as between Submit & Clear) -->
    <tr></tr>
    <tr></tr>
    <tr></tr>
    <tr></tr>
    <tr></tr>
    <tr></tr>
    <tr></tr>
    <tr></tr>
    <tr></tr>
    <tr></tr>
    <tr></tr>
    <tr></tr>

    <!-- Submit Button Row (indented about 1/2 inch) -->
    <tr>
        <td style="padding-left: 0.5in;">
            <button id="submit_button" onclick="submit()" disabled="true"
                        style="color: green; font-size: 30px; padding: 10px 10px">
                        Submit & Email
            </button>
        </td>
        <td>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <div id="submit_confirmation"></div>
        </td>
    </tr>

    <!-- Spacer rows between Submit & Clear -->
    <tr></tr>
    <tr></tr>
    <tr></tr>

    <!-- Clear Button Row -->
    <tr>
        <td></td>
        <td></td>
        <td>
            <button id="clear_button" onclick="clearWithConfirmation()" disabled="true" style="color:red; font-size: 30px; padding: 10px 10px">
                Clear
            </button>
        </td>
    </tr>
</table>


</div>


  <div id="table"></div>

  <tr></tr>
  <tr></tr>
  <tr></tr>

     <!-- Button to manually refresh the Google Sheet -->
  <button id="refresh-btn" onclick="refreshIframe()">Refresh Scoreboard</button>
  
     <!-- Iframe to display the Google Sheet -->
  <iframe id="google-sheet" style="border:none; width: 100%; height: 1200px;"></iframe>


    <p id="instructions">
    <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>Instructions</u></b><br>
            Choose your scheduled Tee Time, input all 
            scores. The App does auto-saves all of your 
            scores every ~25 secs, if problems, 
            re-select your Tee Time & hit "Reload" 
            to regain your scores.</b><b>  If a player drops out, 
            delete the player via the "Delete Player" top boxes-- 
            this deletes all of his data.</b> Then all remaining 
            team points are correct. When ready, use the <span style="font-weight: bold; color: green;">"Submit and Email" </span>
            button to send your scores in and now all players will receive emails with the scorecard. 
            You will see a confirmation of <span style="font-weight: bold; color: green;">"Submit & Email Success - Thanks!" </span> 
            if successful.  If you get a Failure message, restart the App, bring up your tee time/scores, try again. <b>Then you are done!</b><br>
    <br>
            Note: <span style="font-weight: bold; color: red;">"Clear"</span> clears all scores.
    <br><br>
                <span style="background-color: cyan"><b>Albatrosses</b></span>, &nbsp;<span
                style="background-color: orange"><b>Eagles</b></span>, &nbsp;<span
                style="background-color: green"><b> Birdies</b></span>, &nbsp;<span style="background-color: #A9A9A9"><b>Pars</b></span>, & &nbsp;
                <span style="background-color: #D3D3D3"><b>Bogeys</b></span>. &nbsp; <b><i> are highlighted.</b></i>
          </p>


  <script>
  

  document.addEventListener("DOMContentLoaded", function () {
    document.addEventListener("click", function playOnce() {
      const audio = document.getElementById("audio");
      if (audio) {
        audio.play().catch(function (error) {
          console.error("Audio playback failed:", error);
        });
      } else {
        console.warn("Audio element not found.");
      }
      document.removeEventListener("click", playOnce);
    });
  });

  

// Window positioning and tailoring to Mobile and Android -- may need to add for others. 

  window.addEventListener('load', function() {
          // Scroll to top on page load
          window.scrollTo(0, 0);
      });



  document.addEventListener("DOMContentLoaded", function () {
    const isMobile = /Mobi/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);
    const teamInput = document.getElementById("team");

    // Ensure elements exist before modifying them
    const title = document.getElementById("title");
    const course = document.getElementById("course");
    const instructions = document.getElementById("instructions");

    if (isMobile && !isAndroid) {
        // Set readonly for mobile devices (excluding Android)
        if (teamInput) teamInput.readOnly = true;
        document.body.style.zoom = "1.0"; // No zoom for iPhones
    } else if (isAndroid) {
        // Settings for Android devices
        if (teamInput) {
            teamInput.readOnly = false;
            teamInput.style.width = "12ch"; // Set width to 12ch for Android devices
        }
        
        document.body.style.zoom = "1"; // Keep same zoom for Android devices

        // Reduce font size for Android devices
        if (title) title.style.fontSize = "0.3em";
        //if (course) course.style.fontSize = "0.25em";
        if (instructions) instructions.style.fontSize = "0.4em";
    } else {
        // Settings for non-mobile devices (desktop)
        if (teamInput) {
            teamInput.readOnly = false;
            teamInput.style.width = "12ch"; // Set width to 12ch for desktop devices
        }
        document.body.style.zoom = "0.5"; // Zoom out for desktop devices
    }
  });

    window.onload = () => {
      initializeAutoSaveFlag();
      // Other init code like createSaveLoadButtons(), etc.
    };


    // Initialize the flag from localStorage-- to use later for diabling auto save after a submission for the day
  function initializeAutoSaveFlag() {
    const today = new Date().toISOString().slice(0, 10);
    const disabledDate = localStorage.getItem("autosaveDisabledDate");

    if (disabledDate === today) {
      window.isSavingDisabled = true;
      autoSaveSkipNotified = true;
      const autoSaveStatus = document.getElementById("autosave_status");
      if (autoSaveStatus) {
        autoSaveStatus.innerHTML = "<b><i>Auto-save disabled for today (scores already submitted)</i></b>";
        autoSaveStatus.style.color = "red";
      }
    } else {
      window.isSavingDisabled = false;
      autoSaveSkipNotified = false;
    }
  }




// Iframe Code for Scoreboard sheet URLs, placement, sizing, & selection of sheet based on day. 
  
  
    // Define the URLs for asheet (Scoreboard2) and bsheet (Scoreboard)
    const aSheetURL = "https://docs.google.com/spreadsheets/d/1v5wiCZfD5cJbJdOG1n37VymvA5sTI_IcVHjIJEAGp4k/edit?gid=0#gid=0"; 
    // A sheet is Scoreboard2 URL
    const bSheetURL = "https://docs.google.com/spreadsheets/d/1m3bLGCeeF4B-QUDUX_ZLplE_ASC3XU1SR6i3TtzTT5k/edit?gid=0#gid=0";
    // B sheet is Scoreboard URL
  

  /**
     // for G2 test Area
    // Define the URLs for asheet (Scoreboard2) and bsheet (Scoreboard)
     const  aSheetURL = "https://docs.google.com/spreadsheets/d/1xp1WaBTCvKjIma7TRK_Iu_CVAI9CXSLEgp-UwF1WKlI/edit?gid=0#gid=0"; 
    // A sheet is Scoreboard2 URL
    const bSheetURL = "https://docs.google.com/spreadsheets/d/1S9TFC3iTY2KvLcMt6XTlM334ZEbD4EevnFFFIeQGDu0/edit?gid=0#gid=0";
    // B sheet is Scoreboard URL
    
    //  for G-- test area-- to easily copy/edit into a test area

      // Define the URLs for asheet (Scbrd2-Stroke Play/singles) and bsheet (Scoreboard-Stableford/team)
    //const aSheetURL = "...put your test area Scoreboard2 URL here within the quotes ...";
    //const bSheetURL = "...put your test area Scoreboard URL here within the quotes ...";
  

      // Function to set the iframe src based on the day of the week
     //defaulting all days to Singles Stroke play via Scoreboard2 aka aSheet
    */


    function setIframeSrc() {
      const today = new Date().getDay();
      const iframe = document.getElementById('google-sheet');

      // Log the current day of the week to the console
      console.log("Today's day of the week:", today);


      if (today === 0) { // Sunday
          console.log("Loading Sheet Scoreboard");
          iframe.src = bSheetURL;
      } else if (today === 1) { // Monday
          console.log("Loading Sheet Scoreboard");
          iframe.src = bSheetURL;
      } else if (today === 2) { // Tuesday
          console.log("Loading Sheet Scoreboard");
          iframe.src = bSheetURL;
      } else if (today === 3) { // Wednesday
          console.log("Loading Sheet Scoreboard");
          iframe.src = bSheetURL;
      } else if (today === 4) { // Thursday
          console.log("Loading Sheet Scoreboard");
          iframe.src = bSheetURL;
      } else if (today === 5) { // Friday
          console.log("Loading Sheet Scoreboard");
          iframe.src = bSheetURL;
      } else if (today === 6) { // Saturday
          console.log("Loading Sheet Scoreboard");
          iframe.src = bSheetURL;
      }

      // Log the iframe src to the console
      console.log("Iframe src set to:", iframe.src);
    }


// Ensure the iframe loads at the correct size from the beginning and set the initial src
  window.onload = function() {
    console.log("Window loaded");
    const iframe = document.getElementById('google-sheet');
    iframe.style.width = '100%';
    iframe.style.height = '900px'; // Fixed height

    setIframeSrc(); // Set the initial src
  };


//Par Info -- setting Max and Min scores for each hole-- Important, ensure the below "score" functions have the same values

    // Function to calculate minScore -- needs to mimic same as getUserScore()'s value, too
  function getMinScore(par) {
    return Math.max(par - 3, 1); // this is an Albatross, but 1 for Par 3's
  }

  // IMPORTANT - NEED TO SET MAX SCORE IN 2 PLACES BELOW AS THE SAME
    // Function to calculate maxScore  -- needs to mimic same as getUserScore()'s value, too
  function getMaxScore(par) {
     return par + 2; // for double bogey max
    // return par + 3; // for double bogey max
    //return par * 2; // for 2x par max
  }

  function getUserScore(value, par) {
    let userScore = value;
    if (userScore === null || userScore === "") {
        return "";
    }
        // This sets the MAX Score for a Player,  Watch out, "66" < "7", so we use Math functions explicitly.
        // defualt is double bogey max = par +2,  easy to change below ...
     userScore = Math.min(userScore, par + 2); // double bogey is max score
    // userScore = Math.min(userScore, par + 3);  // if you want triple bogey as max
    //userScore = Math.min(userScore, 2 * par);  // if you want 2 x par as max
    
           // This sets the Min Score for a Player
    userScore = Math.max(userScore, Math.max(par - 3, 1)); // this is an Albatross, but 1 smallest -- for Par 3's

    return userScore;
  }


// setting of color highlights score within App based on holes' par
  function getHoleForPlayerColor(userScore, par) {
      // Color 2xBogey or greater = white (no points), bogey or better = shaded to denote points for that hole 
      if (parseInt(userScore) >= (par + 2)) {
          return "#FFFFFF"; // White
      }
      if (parseInt(userScore) >= (par + 1)) {
          return "#D3D3D3"; // Light Gray
      }     
      if (parseInt(userScore) === (par)) {
          return "#A9A9A9"; // Dark Gray
      }            
      if (parseInt(userScore) === (par - 1)) {
          return "#90EE90"; // Green
      }
      if (parseInt(userScore) === (par - 2)) {
          return "#FFA500"; // Orange
      }
      if (parseInt(userScore) === (par - 3)) {
          return "#00FFFF"; // Cyan
      }
      return "";
  }


 // obfuscation start -- if desired


      // global variables to affect the auto saving periods, locks, notifications
    let scoreboardOnlyActive = false;
    let initialDelaySec = 15;
    let saveIntervalSec = 25;
    let saveInterval = null;
    let inputsLocked = false; 
    let forceLock = false;
    let autoSaveSkipNotified = false;  // Global flag to track disabling of auto save notification shown once
    let showServerLogs = true;  // make true to see some server side msgs from the Submit function

   let hasPlayed = false; // Variable to track if the startup sound has already been played


       // only for testing
    function resetAllAutoSaveFlags() {
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith("autosaveDisabledDate_")) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(key => localStorage.removeItem(key));
      console.log(`üö© Reset auto-save flags for teams: ${keysToRemove.join(", ")}`);
    }


    //resetAllAutoSaveFlags();    // only for testing




    function scoreboardOnly() {
      scoreboardOnlyActive = true;
      forceLock = true;
      inputsLocked = true;

      // Disable all inputs except refresh
      const inputs = document.querySelectorAll("input, select, button");
      inputs.forEach(el => {
        if (el.id !== "refresh-btn") {
          el.disabled = true;
        }
      });

      // Disable team selection
      const teamSelect = document.getElementById("team");
      if (teamSelect) {
        teamSelect.onchange = null;
        teamSelect.disabled = true;

        // Optionally just hide the row instead of removing it
        const teamContainer = teamSelect.closest("div");
        if (teamContainer) {
          teamContainer.style.display = "none";
        }
      }

      // Hide team options div if present
      const teamOptions = document.getElementById("team_options");
      if (teamOptions) {
        teamOptions.style.display = "none";
      }

      // Hide team target display
      const teamTarget = document.getElementById("team_target");
      if (teamTarget) {
        teamTarget.style.display = "none";
      }

      // Clear the dynamic table
      const tableDiv = document.getElementById("table");
      if (tableDiv) {
        tableDiv.innerHTML = "";
      }

      // Remove the Scoreboard Use Only button itself
      const scoreboardBtn = document.getElementById("scoreboard_button");
      if (scoreboardBtn) {
        scoreboardBtn.remove();
      }

      console.log("Scoreboard Use Only fully activated: UI frozen, elements hidden or removed.");
    }



  
  

function refreshIframe() {
  const button = document.getElementById("refresh-btn");
  const iframe = document.getElementById("google-sheet");

  // Save scroll position
  const scrollX = window.scrollX || window.pageXOffset;
  const scrollY = window.scrollY || window.pageYOffset;

  // Save original text and add loading state
  if (!button.dataset.originalText) {
    button.dataset.originalText = button.innerHTML;
  }
  button.classList.add("loading");
  button.innerHTML = "Loading‚Ä¶";

  try {
    const currentSrc = iframe.src.split("?")[0];
    const newSrc = `${currentSrc}?t=${new Date().getTime()}`;
    iframe.src = newSrc;
    console.log("Iframe refreshed with new src:", newSrc);
  } catch (e) {
    console.error("Error refreshing iframe:", e);
  }

  // Remove loading state after delay and restore text + scroll position
  setTimeout(() => {
    button.classList.remove("loading");
    if (button.dataset.originalText) {
      button.innerHTML = button.dataset.originalText;
      delete button.dataset.originalText;
    }
    // Restore scroll position
    window.scrollTo(scrollX, scrollY);
  }, 1500);
}







  document.addEventListener("DOMContentLoaded", function() {
    const teeTimeInput = document.getElementById('team');

    // Listen for changes in the tee time input field
    teeTimeInput.addEventListener('input', function() {
      if (teeTimeInput.value) {
        // Scale down the page to 1.4x after selecting a tee time
        document.documentElement.style.zoom = '1.4';
        }
    });
    });



function createCheckboxRow(teamConfig) {
  const containerDiv = document.createElement("div");
  containerDiv.style.display = "flex";
  containerDiv.style.alignItems = "center";

  // Add spacing row
  const nullRowAbove = document.createElement("div");
  nullRowAbove.style.height = "20px"; 
  containerDiv.appendChild(nullRowAbove);

  // Add header for delete player
  const headerDiv = document.createElement("div");
  headerDiv.innerHTML = "<b style='font-size: 1.4em; color: red;'>Delete Player</b>"; 
  headerDiv.style.marginRight = "20px"; 
  containerDiv.appendChild(headerDiv);

  // Create a single row of checkboxes
  const boxDiv = document.createElement("div");

  for (let j = 0; j < teamConfig.players.length; j++) {
    const checkboxContainer = document.createElement("label");
    checkboxContainer.style.display = "inline-block";
    checkboxContainer.style.marginLeft = "50px";
    checkboxContainer.style.width = "30px";
    checkboxContainer.style.height = "30px";
    checkboxContainer.style.backgroundColor = "red";
    checkboxContainer.style.borderRadius = "4px";
    checkboxContainer.style.cursor = "pointer";
    checkboxContainer.style.textAlign = "center";
    checkboxContainer.style.lineHeight = "30px";

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.style.opacity = "0"; 
    checkbox.style.width = "30px"; 
    checkbox.style.height = "30px"; 
    checkbox.style.margin = "0"; 

    // Handle checkbox actions with pop-up confirmation
    checkbox.onchange = function () {
      if (checkbox.checked) {
        const playerName = document.getElementById(idPlayerName(j)).value;
        const confirmation = confirm(
          `Do you really want to delete ${playerName}, his Target Pts, and Scores?\n\n` +
          `If sure, hit OK, if not, hit Cancel.\n\n` +
          `Note: After the deletion, you have about 5 secs average to hit the Reload button to retrieve the deleted info. But after that, it is gone.`
        );

        if (!confirmation) {
          checkbox.checked = false; // Ensure checkbox remains unchecked if canceled
          return;
        }

        checkboxContainer.style.color = "white"; 
        checkboxContainer.innerHTML = "‚úî"; 
        deletePlayerAndTarget(j, checkbox); 
        updateTeamTarget(teamConfig.players.length); 
      } else {
        checkboxContainer.style.color = ""; 
        checkboxContainer.innerHTML = ""; 
      }
    };

    checkboxContainer.appendChild(checkbox); 
    boxDiv.appendChild(checkboxContainer); 
  }

  containerDiv.appendChild(boxDiv);


  // Add final spacing row
  const nullRowBelow = document.createElement("div");
  nullRowBelow.style.height = "200px"; 
  containerDiv.appendChild(nullRowBelow);

  return containerDiv;
}





  const RESULTS = [{
        name: "Total 18",
        startInclusive: 0,
        endExclusive: 18,
    }, {
        name: "Front 9",
        startInclusive: 0,
        endExclusive: 9
    }, {
        name: "Back 9",
        startInclusive: 9,
        endExclusive: 18
    }];

  const TEST_CONFIG = {
      "courseConfig": {
          "date": "2000-01-01",
          "courseName": "Test Course",
          "pars": [4, 4, 5, 3, 4, 5, 4, 3, 4, 4, 4, 5, 3, 4, 4, 3, 4, 5]
      },
      "allTeamConfigs": [
          {
              "teamName": "9:20",
              "players": [
                  { "playerName": "AAAA AAAAAAA", "playerTarget": 24 },
                  { "playerName": "BBBBB BBBBBB", "playerTarget": 21 },
                  { "playerName": "CCC CCCCCC", "playerTarget": 15 }
              ]
          },
          {
              "teamName": "9:30",
              "players": [
                  { "playerName": "DDDDD DDDD", "playerTarget": 29 },
                  { "playerName": "EEEE EEEEEEEEE", "playerTarget": 25 },
                  { "playerName": "FFFFF FFFFFF", "playerTarget": 21 },
                  { "playerName": "GGG GGGGG", "playerTarget": 15 }
                  // { "playerName": "HHHHHHHHH", "playerTarget": 21 },
                  // { "playerName": "IIIIIIIII", "playerTarget": 15 }
              ]
          }
      ]
  }


  function spreadsheetConfig() {
      // This function exists to making testing iteration more straightforward.
      // AppScript will inject the variable CONFIG *before* the HTML content.
      if (typeof CONFIG === "undefined") {
          console.log("Falling back to TEST_CONFIG.");
          return TEST_CONFIG;
      }
      console.log("Loaded config:\n" + JSON.stringify(CONFIG));
      return CONFIG;
  }

  createScorecard(RESULTS, spreadsheetConfig());



  function createScorecard(RESULTS, spreadsheetConfig) {
      document.getElementById("course").textContent = spreadsheetConfig.courseConfig.courseName;
      document.getElementById("date").textContent = spreadsheetConfig.courseConfig.date;

      document.getElementById("team").onchange = function (event) {
          teamOnchange(RESULTS, spreadsheetConfig);
      };

      createTeamOptions(spreadsheetConfig.allTeamConfigs); // This already populates the select box
  }


let scoreKeeper;
let teamName;

function getScorer(teamConfig) {
  console.log("getScorer called with teamConfig:", teamConfig);

  if (!teamConfig || !teamConfig.players || teamConfig.players.length === 0) {
    alert("No players found in this team.");
    return;
  }

  const popup = document.createElement('div');
  popup.style.position = 'fixed';
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';
  popup.style.background = 'white';
  popup.style.border = '2px solid #ccc';
  popup.style.borderRadius = '10px';
  popup.style.padding = '20px';
  popup.style.zIndex = '1000';
  popup.style.textAlign = 'center';
  popup.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';

  popup.innerHTML = `
    <div style="color: red; font-weight: bold; font-size: 1.2em;">ONLY ONE OF THESE PLAYERS (AT A TIME) MAY KEEP SCORE FOR THIS TEAM </div>
    <div style="height: 1em;"></div>
    <div style="color: blue; font-size: 1.1em; margin-bottom: 10px;">Which is the Scorekeeper?</div>
  `;

  const playerNames = teamConfig.players.map(p => p.playerName);

  playerNames.forEach(name => {
    const button = document.createElement('button');
    button.textContent = name;
    button.style.display = 'block';
    button.style.width = '100%';
    button.style.margin = '20px 0';
    button.style.padding = '10px';
    button.style.fontSize = '1em';
    button.onclick = () => {
      scoreKeeper = name;
      teamName = teamConfig.teamName;
      console.log("Scorekeeper selected:", name);
      document.body.removeChild(popup);
      google.script.run.recordScorerActivity({
        teamName: teamConfig.teamName,
        playerName: name,
        activity: "Scorekeeper"
      });
    };
    popup.appendChild(button);
  });

  // Spacer
  const spacer = document.createElement('div');
  spacer.style.height = '20px';
  popup.appendChild(spacer);

  // Scoreboard Use Only button
  const scoreboardButton = document.createElement('button');
  scoreboardButton.textContent = 'Scoreboard Use Only';
  scoreboardButton.style.display = 'block';
  scoreboardButton.style.width = '100%';
  scoreboardButton.style.margin = '10px 0';
  scoreboardButton.style.padding = '10px';
  scoreboardButton.style.fontSize = '1em';
  scoreboardButton.style.backgroundColor = 'green';
  scoreboardButton.style.color = 'white';
  scoreboardButton.style.border = 'none';
  scoreboardButton.style.cursor = 'pointer';

  scoreboardButton.onclick = () => {
    scoreboardOnly();  // Call your locking function
    document.body.removeChild(popup);
  };

  popup.appendChild(scoreboardButton);

  document.body.appendChild(popup);
}




  function createTeamOptions(allTeamConfigs) {
    const teamSelect = document.getElementById("team");  // Assuming 'team' is the id of your <select> element

    // Clear existing options except the placeholder
    teamSelect.innerHTML = '<option value="" disabled selected>Select</option>';

    // Populate the <select> options with team names
    for (let teamIndex = 0; teamIndex < allTeamConfigs.length; teamIndex++) {
        const teamOption = document.createElement("option");
        teamOption.value = allTeamConfigs[teamIndex].teamName;
        teamOption.text = allTeamConfigs[teamIndex].teamName;  // Set display text for option
        teamSelect.appendChild(teamOption);
    }

    // Add an event listener to disable the select once a team is selected
    teamSelect.addEventListener('change', function() {
        if (teamSelect.value) {  // Ensure a valid selection (not the placeholder)
            teamSelect.disabled = true;  // Disable the select after selection
            console.log(`Selected team: ${teamSelect.value}`);
        }
    });
  }


 function clearLocalStorageButPreserveTeamsAutosave(teams) {
  // Build the keys to keep based on teams array
  const keysToKeep = teams.map(team => "autosaveDisabledDate_" + team.teamName);

  // Backup the values of those keys
  const backup = {};
  keysToKeep.forEach(key => {
    const val = localStorage.getItem(key);
    if (val !== null) {
      backup[key] = val;
    }
  });

  // Clear everything
  localStorage.clear();

  // Restore preserved keys
  Object.entries(backup).forEach(([key, val]) => {
    localStorage.setItem(key, val);
  });

  console.log("Preserved keys after clear:", Object.keys(backup));
}



function teamOnchange(RESULTS, spreadsheetConfig) {
  console.log("teamOnchange start");

  // Block everything if Scoreboard Only mode is active
  if (scoreboardOnlyActive) {
    console.log("teamOnchange blocked due to Scoreboard Only mode.");
    return;
  }

  // Remove Scoreboard Use Only button if present
  const scoreboardBtn = document.getElementById("scoreboard_button");
  if (scoreboardBtn) {
    scoreboardBtn.remove();
    console.log("Scoreboard Use Only button removed.");
  }

  // Clear localStorage except autosave flags for all teams
  clearLocalStorageButPreserveTeamsAutosave(spreadsheetConfig.allTeamConfigs);

  // Get selected team configuration
  const selectedTeamConfig = getSelectedTeamConfig(spreadsheetConfig.allTeamConfigs);
  console.log("Loading team:\n" + JSON.stringify(selectedTeamConfig));

  // Clear main table container
  const tableDiv = document.getElementById("table");
  tableDiv.innerHTML = "";

  // Insert checkbox row at the top
  const checkboxRow = createCheckboxRow(selectedTeamConfig);
  tableDiv.appendChild(checkboxRow);

  // Create Save/Load buttons and autosave status display
  createSaveLoadButtons(spreadsheetConfig, selectedTeamConfig);

  // Add spacing below buttons
  const breakDiv = document.createElement("div");
  breakDiv.style.height = "20px";
  tableDiv.appendChild(breakDiv);

  // Create the scorecard table using provided data
  createScorecardTable(RESULTS, spreadsheetConfig.courseConfig, selectedTeamConfig);

  // Enable form buttons
  document.getElementById("submit_button").disabled = false;
  document.getElementById("clear_button").disabled = false;

  // Load saved scores from Google Sheets for the selected team
  const teamName = document.getElementById("team").value;
  google.script.run
    .withSuccessHandler(populateScorecardWithSavedResults)
    .withFailureHandler(function (error) {
      console.error("Failed to load scores:", error);
      alert("Failed to load scores. Please try again or check the team name.");
    })
    .loadScoresForTeam(teamName);

  // Play sound only on first team change
  if (!hasPlayed) {
    const audio = document.getElementById("audio");
    audio.play()
      .then(() => {
        console.log("Audio played successfully.");
      })
      .catch((error) => {
        console.error("Audio playback failed:", error);
      });
    hasPlayed = true;
  }

  // Update scorer UI or logic
  getScorer(selectedTeamConfig);

//resetAutoSaveFlagForCurrentTeam();   // only for testing

}


      // only for testing
    function resetAutoSaveFlagForCurrentTeam() {
      const teamName = document.getElementById("team")?.value || "UNKNOWN_TEAM";
      const teamKey = `autosaveDisabledDate_${teamName}`;
      localStorage.removeItem(teamKey);
      console.log(`üö© Auto-save flag reset for team "${teamName}". Current flag value:`, localStorage.getItem(teamKey));
    }





function createSaveLoadButtons(spreadsheetConfig, selectedTeamConfig) {
  try {
    console.log("‚û° createSaveLoadButtons called.");

    const table = document.getElementById("table");
    if (!table) {
      console.error("‚ùå Table element with id 'table' not found.");
      return;
    }

    // Remove any previous button sets if they exist
    const existingSubTables = table.querySelectorAll("table");
    existingSubTables.forEach(sub => sub.remove());

    const subTable = document.createElement("table");
    const tr = document.createElement("tr");

    // Create Save Button
    const saveElement = document.createElement("td");
    const saveButtonContainer = createSaveButton(spreadsheetConfig, selectedTeamConfig);
    const buttonEl = saveButtonContainer.querySelector("button");
    console.log("‚úÖ Save button created.");

    // Create Load Button
    const loadElement = document.createElement("td");
    const loadButton = createLoadButton();
    console.log("‚úÖ Load button created.");

    // Status Display for AutoSave
    const statusElement = document.createElement("td");
    const autoSaveStatus = document.createElement("span");
    autoSaveStatus.id = "autosave_status";
    autoSaveStatus.style.fontSize = "20px";
    statusElement.appendChild(autoSaveStatus);

    // Append elements
    saveElement.appendChild(saveButtonContainer);
    loadElement.appendChild(loadButton);

    // Apply spacing
    saveElement.style.paddingRight = "25px";
    saveElement.style.paddingBottom = "10px";
    saveElement.style.paddingTop = "10px";
    loadElement.style.paddingLeft = "20px";
    loadElement.style.paddingBottom = "10px";
    loadElement.style.paddingTop = "10px";

    // Build table row
    tr.appendChild(saveElement);
    tr.appendChild(loadElement);
    tr.appendChild(statusElement);
    subTable.appendChild(tr);

    // Append to main table
    table.appendChild(subTable);

    // **Check autosave disabled key here**
    const teamName = selectedTeamConfig?.team || document.getElementById("team")?.value || "UNKNOWN_TEAM";
    const teamKey = `autosaveDisabledDate_${teamName}`;
    const storedDate = localStorage.getItem(teamKey);
    const today = new Date().toISOString().slice(0, 10);

    // Set auto-save disabled flag for today
    window.autoSaveManuallyDisabled = (storedDate === today);

    if (window.autoSaveManuallyDisabled) {
      autoSaveStatus.innerHTML = "<b>Auto-save disabled for today (scores already submitted)</b>";
      autoSaveStatus.style.color = "red";
      console.log(`üõë Autosave is disabled for ${teamName} today.`);
    } else {
      autoSaveStatus.innerHTML = "<b>Auto-save is active</b>";
      autoSaveStatus.style.color = "green";
      console.log(`‚úÖ Autosave is active for ${teamName}.`);
    }

    // Auto-save interval logic...
    if (buttonEl && typeof initialDelaySec !== "undefined" && typeof saveIntervalSec !== "undefined") {
      setTimeout(() => {
        console.log("‚åõ Initial delay complete");
        saveInterval = setInterval(() => {
          if (inputsLocked) {
            console.log("üö´ Skipping due to lock");
            return;
          }

          if (window.autoSaveManuallyDisabled) {
            console.log("üö´ Skipping auto-save due to submission today");
            const autoSaveStatus = document.getElementById("autosave_status");
            if (autoSaveStatus) {
              autoSaveStatus.innerHTML = "<b>Auto-save disabled for today (scores already submitted)</b>";
              autoSaveStatus.style.color = "red";
            }
            return;
          }

          console.log("üíæ Auto-save triggered");
          buttonEl.click();
        }, saveIntervalSec * 1000);
      }, initialDelaySec * 1000);
    } else {
      console.error("‚ùå Could not start auto-save ‚Äî missing button or delay values");
    }
  } catch (e) {
    console.error("‚ùå Exception in createSaveLoadButtons:", e);
  }
}




function createSaveButton(spreadsheetConfig, selectedTeamConfig) {
  const container = document.createElement("div");

  const button = document.createElement("button");
  button.innerHTML = "Save";
  button.style.fontSize = "30px";
  button.style.color = "green";
  button.style.padding = "10px 10px";
  button.id = "save_button"; // ‚úÖ Needed for CSS and control

  const statusSpan = document.createElement("span");
  statusSpan.style.fontSize = "20px";
  statusSpan.style.color = "green";
  statusSpan.style.marginLeft = "10px";
  statusSpan.id = "save_status";

  let isSaving = false;

  button.onclick = function () {
    if (isSaving || inputsLocked) {
      console.log("Save is temporarily disabled or already in progress.");
      return;
    }

    isSaving = true;

    const originalText = button.textContent;
    button.textContent = "Saving...";
    button.classList.add("loading");

    let out = [];
    for (let currPlayerIndex = 0; currPlayerIndex < selectedTeamConfig.players.length; currPlayerIndex++) {
      let currPlayerScores = [];
      currPlayerScores.push(document.getElementById(idPlayerName(currPlayerIndex)).value);
      currPlayerScores.push(document.getElementById(idTarget(currPlayerIndex)).value);

      for (let holeIndex = 0; holeIndex < spreadsheetConfig.courseConfig.pars.length; holeIndex++) {
        currPlayerScores.push(document.getElementById(idHolePlayer(holeIndex, currPlayerIndex)).value);
      }

      out.push(currPlayerScores);
    }

    console.log("Sending to backend: " + JSON.stringify(out));

    google.script.run
      .withSuccessHandler(function () {
        isSaving = false;
        button.textContent = originalText;
        button.classList.remove("loading");

        const now = new Date();
        const time = `${now.getHours()}:${now.getMinutes().toString().padStart(2, "0")}`;
        statusSpan.innerHTML = `<b><i>Saved at</i></b> ${time}`;
        statusSpan.style.color = "green";
      })
      .withFailureHandler(function (error) {
        isSaving = false;
        button.textContent = originalText;
        button.classList.remove("loading");

        statusSpan.textContent = "Failed to Save";
        statusSpan.style.color = "red";
        console.error("Error saving scores:", error);
      })
      .saveScoresForTeam(document.getElementById("team").value, out);
  };

  window.saveButtonReference = button;
  container.appendChild(button);
  container.appendChild(statusSpan);
  return container;
}


function createLoadButton() {
  const container = document.createElement("div");

  const button = document.createElement("button");
  button.id = "reload_button";
  button.innerHTML = "Re-Load";
  button.style.fontSize = "30px";
  button.style.color = "blue";
  button.style.padding = "10px 10px";

  const statusSpan = document.createElement("span");
  statusSpan.id = "reload_status";
  statusSpan.style.fontSize = "20px";
  statusSpan.style.color = "blue";
  statusSpan.style.marginLeft = "10px";

  button.onclick = function () {
    if (button.classList.contains("loading")) return;

    button.classList.add("loading");

    const teamName = document.getElementById("team").value;
    google.script.run
      .withSuccessHandler(function (results) {
        populateScorecardWithSavedResults(results);
        const now = new Date();
        const time = `${now.getHours()}:${now.getMinutes().toString().padStart(2, "0")}`;
        statusSpan.innerHTML = `<b><i>Re-Loaded at</i></b> ${time}`;
        statusSpan.style.color = "blue";
        button.classList.remove("loading");
      })
      .withFailureHandler(function (error) {
        statusSpan.textContent = "Failed to Re-Load";
        statusSpan.style.color = "red";
        console.error("Error loading scores:", error);
        button.classList.remove("loading");
      })
      .loadScoresForTeam(teamName);
  };

  container.appendChild(button);
  container.appendChild(statusSpan);

  return container;
}



  function populateScorecardWithSavedResults(allPlayerScores) {
    const paramSpreadsheetConfig = spreadsheetConfig();

    console.log("Loading saved scores: " + JSON.stringify(allPlayerScores));

    const selectedTeamConfig = getSelectedTeamConfig(paramSpreadsheetConfig.allTeamConfigs);

    for (let currPlayerIndex = 0; currPlayerIndex < selectedTeamConfig.players.length; currPlayerIndex++) {
        if (currPlayerIndex >= allPlayerScores.length) {
            break;
        }
        let currPlayerScores = allPlayerScores[currPlayerIndex];

        console.log(`Processing player ${currPlayerIndex}: ${JSON.stringify(currPlayerScores)}`);

        // Set player name
        if (currPlayerScores.length >= 1) {
            const playerNameInput = document.getElementById(idPlayerName(currPlayerIndex));
            if (playerNameInput) {
                playerNameInput.value = currPlayerScores[0];
                console.log(`Set player name: ${currPlayerScores[0]}`);
            } else {
                console.log(`Player name input not found for player index ${currPlayerIndex}`);
            }
        }

        // Set target
        if (currPlayerScores.length >= 2 && typeof currPlayerScores[1] === "number") {
            const targetInput = document.getElementById(idTarget(currPlayerIndex));
            if (targetInput) {
                targetInput.value = currPlayerScores[1];
                targetInput.oninput();
                console.log(`Set target: ${currPlayerScores[1]}`);
            } else {
                console.log(`Target input not found for player index ${currPlayerIndex}`);
            }
        }

        // Set hole scores
        for (let holeIndex = 0; holeIndex < paramSpreadsheetConfig.courseConfig.pars.length && holeIndex < (currPlayerScores.length - 2); holeIndex++) {
            let maybeScore = currPlayerScores[holeIndex + 2];
            const select = document.getElementById(idHolePlayer(holeIndex, currPlayerIndex));
            if (select) {
                if (typeof maybeScore === "number" && maybeScore > 0) {
                    select.value = maybeScore;
                } else {
                    select.value = "";
                }
                // Trigger the change event
                const event = new Event('change', { bubbles: true });
                select.dispatchEvent(event);
                console.log(`Set score for hole ${holeIndex}: ${select.value}`);
            } else {
                console.log(`Score select not found for hole ${holeIndex} and player index ${currPlayerIndex}`);
            }
        }
    }
  }

  function getSelectedTeamConfig(allTeamConfigs) {
    const teamName = document.getElementById("team").value;

    let selectedTeamConfig = {
    "teamName": "",
    "players": [
    { "playerName": "", "playerTarget": null },
    { "playerName": "", "playerTarget": null },
    { "playerName": "", "playerTarget": null },
    { "playerName": "", "playerTarget": null },
    ]
    };

    for (let teamConfig of allTeamConfigs) {
    if (teamName === teamConfig.teamName) {
    selectedTeamConfig = teamConfig;
    }
    }

    return selectedTeamConfig;
  }


    // Function that gets called after the page expands
  function createScorecardTable(RESULTS, courseConfig, teamConfig) {
    document.getElementById("table").appendChild(
    generateTable(RESULTS, courseConfig, teamConfig));

    for (const result of RESULTS) {
      const refRow = document.getElementById(idHoleRow(result.endExclusive - 1));
      const refTable = refRow.parentElement;

      const newRows = generateResultTable(result, teamConfig.players.length);

      // Loop over these rows in reverse, so they appear in order.
      for (let rowIndex = newRows.length - 1; rowIndex >= 0; rowIndex--) {
          const placeholderRow = refTable.insertRow(refRow.rowIndex + 1);
          refTable.replaceChild(newRows[rowIndex], placeholderRow);
      }
    }

      // We could have loaded some cached scores.
    updateAllStats(RESULTS, courseConfig.pars, teamConfig.players.length);

  }


  function generateTable(results, courseConfig, teamConfig) {
      const table = document.createElement("table");

      const numHoles = courseConfig.pars.length;

      const nameRow = generateNameRow(teamConfig);
      table.appendChild(nameRow);

      const targetRow = generateTargetRow(results, courseConfig.pars, teamConfig);
      table.appendChild(targetRow);

      for (let holeIndex = 0; holeIndex < numHoles; holeIndex++) {
          const row = generateHoleRow(results, courseConfig.pars, holeIndex, teamConfig.players.length);
          table.appendChild(row);
      }

      return table;

  }



function deletePlayerAndTarget(playerIndex, checkbox) {
  saveBeforeDelete();

  document.getElementById(idPlayerName(playerIndex)).value = "x";
  document.getElementById(idTarget(playerIndex)).value = "0";

  // Clear scores for the selected deleted player
  clearScoresAndCacheForPlayer(playerIndex);

  // Update localStorage
  localStorage.removeItem(idPlayerName(playerIndex));
  localStorage.removeItem(idTarget(playerIndex));

  for (let holeIndex = 0; holeIndex < 18; holeIndex++) {
    const scoreId = idHolePlayer(holeIndex, playerIndex);
    localStorage.removeItem(scoreId);
  }

  updateTeamTarget(getSelectedTeamConfig(spreadsheetConfig().allTeamConfigs).players.length);
  console.log("New Team Target After Player Deletion:", document.getElementById("team_target").textContent);
}



 function saveBeforeDelete() {
      const localSpreadsheetConfig = spreadsheetConfig();
      const selectedTeamConfig = getSelectedTeamConfig(localSpreadsheetConfig.allTeamConfigs);
                  
      // --- Save Scores Before Submitting ---
      // Build an array of raw scores (similar to save button)
    let out = [];
    for (let currPlayerIndex = 0; currPlayerIndex < selectedTeamConfig.players.length; currPlayerIndex++) {
      let currPlayerScores = [];
      currPlayerScores.push(document.getElementById(idPlayerName(currPlayerIndex)).value);
      currPlayerScores.push(document.getElementById(idTarget(currPlayerIndex)).value);

      for (let holeIndex = 0; holeIndex < localSpreadsheetConfig.courseConfig.pars.length; holeIndex++) {
        currPlayerScores.push(document.getElementById(idHolePlayer(holeIndex, currPlayerIndex)).value);
      }

      out.push(currPlayerScores);
    }

    console.log("Saving before submitting: " + JSON.stringify(out));

    google.script.run
      .withSuccessHandler(function () {
        // Save to localStorage
        localStorage.setItem("savedScores", JSON.stringify(out));

        const now = new Date();
        const hours = now.getHours().toString();
        const minutes = now.getMinutes().toString().padStart(2, "0");
        const time = `${hours}:${minutes}`;
        document.getElementById("save_status").innerHTML =
          "<b><i>Saved at</i></b> " + time;
      })
      .withFailureHandler(function (error) {
        const statusElem = document.getElementById("save_status");
        statusElem.textContent = "Failed to Save";
        statusElem.style.cssText =
          "font-size: 40px; font-weight: bold; color: red;";
        console.error("Error saving scores:", error);
      })
      .saveScoresForTeam(document.getElementById("team").value, out);
  }



  function generateNameRow(teamConfig) {
    const row = document.createElement("tr");
    row.classList.add("sticky-header"); // Add sticky header class
    const headerCell = document.createElement("td");
    headerCell.textContent = "Name";
    headerCell.style.fontSize = "1.5em"; // Set the font size
    headerCell.style.fontWeight = "bold"; // Set the font weight
    row.appendChild(headerCell);
    for (let playerIndex = 0; playerIndex < teamConfig.players.length; playerIndex++) {
      const playerCell = document.createElement("td");
      const input = document.createElement("input");
      input.type = "text";
      input.id = idPlayerName(playerIndex);
      input.style.fontFamily = "'Arial Narrow', Arial, sans-serif";
      input.style.fontSize = "20px";
      input.style.padding = "5px 5px";
      input.style.width = "8ch";
      input.style.fontWeight = "bold";
      input.value = teamConfig.players[playerIndex].playerName;
      playerCell.appendChild(input);
      row.appendChild(playerCell);
    }
    return row;
  }


function generateTargetRow(results, pars, teamConfig) {
    const row = document.createElement("tr");
    const headerCell = document.createElement("td");
    headerCell.textContent = "Target";
    headerCell.style.fontSize = "1.5em"; // Set the inline font size
    headerCell.style.fontWeight = "bold"; // Set the inline font weight to bold
    row.appendChild(headerCell);
    let teamTarget = 0;
    for (let playerIndex = 0; playerIndex < teamConfig.players.length; playerIndex++) {
        const currPlayerIndex = playerIndex;
        const playerCell = document.createElement("td");
        playerCell.align = "center";
        const input = document.createElement("input");
        input.type = "number";
        input.id = idTarget(playerIndex);
        input.style.width = "3ch";
        input.style.fontSize = "1.2em"; // Set the font size to 1.2em
        input.disabled = false;
        const playerTarget = teamConfig.players[playerIndex].playerTarget;
        input.value = playerTarget;
        const playerTargetOrZero = parseInt(playerTarget);
        if (!isNaN(playerTargetOrZero)) {
            teamTarget += playerTargetOrZero;
        }
        input.min = 0;
        input.oninput = function (event) {
            updateStats(results, pars, teamConfig.players.length, currPlayerIndex);
            updateTeamTarget(teamConfig.players.length);
        };
        playerCell.appendChild(input);
        row.appendChild(playerCell);
    }
    document.getElementById("team_target").textContent = teamTarget;
    return row;
}


  function generateHoleRow(results, pars, holeIndex, numPlayers) {
      const row = document.createElement("tr");

      row.id = idHoleRow(holeIndex);

      const headerCell = generateHoleHeader(holeIndex, pars[holeIndex]);
      row.appendChild(headerCell);

      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const holeCell = generateHoleForPlayer(results, pars, holeIndex, numPlayers, playerIndex);
          row.appendChild(holeCell);
      }

        // Call the resize function after generating the row
    //resizePage();

      return row;
  }

  function generateHoleHeader(holeIndex, par) {
      const cell = document.createElement("td");
      cell.textContent = (holeIndex + 1) + " (" + par + ")";
      cell.style.fontSize = "1.5em"; // Set the inline font size to 1.5em

      return cell;
  }




  function generateHoleForPlayer(results, pars, holeIndex, numPlayers, playerIndex) {
    const cell = document.createElement("td");
    cell.style.textAlign = "center"; // Use style instead of align

    const select = document.createElement("select");
    const id = idHolePlayer(holeIndex, playerIndex);
    select.id = id;
    select.style.width = "5ch"; // Set width to 5ch
    select.style.fontSize = "1.2em"; // Increase font size to make text taller
    select.style.height = "2.5em"; // Increase height to make the box taller
    select.style.padding = "2px"; // Adjust padding if needed
    select.style.boxSizing = "border-box"; // Ensure padding is included in the height

    const possibleSavedScore = localStorage.getItem(id);
    const userScore = possibleSavedScore !== null ? possibleSavedScore : "";

    const minScore = getMinScore(pars[holeIndex]); // Calculate minScore using the function defined earlier
    const maxScore = getMaxScore(pars[holeIndex]); // Calculate maxScore using the function defined earlier

    // Add a null option
    const nullOption = document.createElement("option");
    nullOption.value = "";
    nullOption.text = ""; // Placeholder text if desired
    if (userScore === "") {
        nullOption.selected = true;
    }
    select.appendChild(nullOption);

    for (let score = minScore; score <= maxScore; score++) {
        const option = document.createElement("option");
        option.value = score;
        option.text = score;
        if (score == userScore) {
            option.selected = true;
        }
        select.appendChild(option);
    }

    // Apply initial background color based on userScore
    select.style.color = "black";
    select.style.backgroundColor = userScore === "" ? "yellow" : getHoleForPlayerColor(userScore, pars[holeIndex]);

    select.addEventListener('change', function(event) {
        const selectedScore = event.target.value;

        select.style.backgroundColor = selectedScore === "" ? "yellow" : getHoleForPlayerColor(selectedScore, pars[holeIndex]);
       
        localStorage.setItem(id, selectedScore);
        updateStats(results, pars, numPlayers, playerIndex);

        // Apply bold and larger font size to the selected option
        select.style.fontWeight = selectedScore ? "bold" : "normal";
        select.style.fontSize = "1.2em"; // Adjust font size as needed

        // Simulate the bold effect by adding a pseudo element for the selected option
        const options = select.querySelectorAll('option');
        options.forEach(option => {
            if (option.value === selectedScore) {
                option.style.fontWeight = "bold";
                option.style.fontSize = "1.2em";
            } else {
                option.style.fontWeight = "normal";
                option.style.fontSize = "1em"; // Default size
            }
        });
    });

    cell.appendChild(select);
    return cell;
  }


  function generateResultTable(partialResult, numPlayers) {
    const headerRow = document.createElement("tr");
    headerRow.textContent = partialResult.name;
    headerRow.style = "font-weight: bold; text-decoration: underline; font-size: 1.5em;";

    const scoreRow = generateResultScoreRow(partialResult.name, numPlayers);
    scoreRow.style.fontSize = "1.5em";

    const pointsRow = generateResultPointsRow(partialResult.name, numPlayers);
    pointsRow.style.fontSize = "1.5em";

    const netRow = generateResultNetRow(partialResult.name, numPlayers);
    netRow.style.fontSize = "1.5em";

    const pointsTeamRow = generateResultPointsTeamRow(partialResult.name);
    pointsTeamRow.style.fontSize = "1.5em";

    const netTeamRow = generateResultNetTeamRow(partialResult.name);
    netTeamRow.style.fontSize = "1.5em";

    return [headerRow, scoreRow, pointsRow, netRow, pointsTeamRow, netTeamRow];
  }


  function generateResultScoreRow(resultName, numPlayers) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Score";
      row.appendChild(headerCell);

      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const scoreCell = document.createElement("td");
          scoreCell.align = "center";
          scoreCell.id = idResultScorePlayer(resultName, playerIndex);
          scoreCell.textContent = 0;
          row.appendChild(scoreCell);
      }

      return row;
  }

  function generateResultPointsRow(resultName, numPlayers) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Points";
      row.appendChild(headerCell);

      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const pointsCell = document.createElement("td");
          pointsCell.align = "center";
          pointsCell.id = idResultPointsPlayer(resultName, playerIndex);
          pointsCell.textContent = 0;
          row.appendChild(pointsCell);
      }

      return row;
  }

  function generateResultNetRow(resultName, numPlayers) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Net";
      row.appendChild(headerCell);

      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const netCell = document.createElement("td");
          netCell.align = "center";
          netCell.id = idResultNetPlayer(resultName, playerIndex);
          netCell.textContent = "";
          row.appendChild(netCell);
      }

      return row;
  }

  function generateResultPointsTeamRow(resultName) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Team Points";
      headerCell.style = "font-weight: bold";
      row.appendChild(headerCell);

      const pointsCell = document.createElement("td");
      pointsCell.style = "font-weight: bold";
      pointsCell.align = "center";
      pointsCell.id = idResultPointsTeam(resultName);
      pointsCell.textContent = 0;
      row.appendChild(pointsCell);

      return row;
  }

  function generateResultNetTeamRow(resultName) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Team Net";
      headerCell.style = "font-weight: bold";
      row.appendChild(headerCell);

      const netCell = document.createElement("td");
      netCell.style = "font-weight: bold";
      netCell.align = "center";
      netCell.id = idResultNetTeam(resultName);
      netCell.textContent = "";
      row.appendChild(netCell);

      return row;
  }



  function applyPerformanceColor(cell, actual, expected, direction = "higher") {
      console.log("applyPerformanceColor called with:", { cellId: cell.id, actual, expected, direction });
      //console.trace();  // üëà shows exact call location in the console
      
      console.log("applyPerformanceColor called with:", { actual, expected, direction });

      if (isNaN(actual) || isNaN(expected)) {
          cell.style.color = ""; // default black
          return;
      }

      // Black if both actual and expected are zero (start state)
      if (actual === 0 && expected === 0) {
          cell.style.color = "";
          return;
      }

      // For other stats, if actual is zero, keep black (start)
      if (actual === 0) {
          cell.style.color = "";
          return;
      }

      // Ratio for coloring (higher or lower is better)
      const ratio = direction === "higher" ? actual / expected : expected / actual;

      if (ratio >= 0.95) {
          cell.style.color = "green";
      } else if (ratio >= 0.85) {
          cell.style.color = "orange";
      } else {
          cell.style.color = "red";
      }
  }






  function updateAllStats(results, pars, numPlayers) {
      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          updateStats(results, pars, numPlayers, playerIndex);
      }
  }

  function updateStats(results, pars, numPlayers, playerIndex) {
      const score = computeScore(pars.length, playerIndex);
      const points = computePoints(pars, playerIndex);

      for (let result of results) {
          updateResult(result, pars, playerIndex, score, points);

          // TEAM POINTS
          let pointsTeam = 0;
          for (let currPlayerIndex = 0; currPlayerIndex < numPlayers; currPlayerIndex++) {
              const playerPointsOrNaN = parseInt(
                  document.getElementById(idResultPointsPlayer(result.name, currPlayerIndex)).textContent
              );
              if (!isNaN(playerPointsOrNaN)) {
                  pointsTeam += playerPointsOrNaN;
              }
          }

          const teamPointsCell = document.getElementById(idResultPointsTeam(result.name));
          teamPointsCell.textContent = pointsTeam;

          // TEAM TARGET
          let teamTarget = 0;
          for (let currPlayerIndex = 0; currPlayerIndex < numPlayers; currPlayerIndex++) {
              const playerTarget = parseInt(document.getElementById(idTarget(currPlayerIndex)).value);
              if (!isNaN(playerTarget)) {
                  teamTarget += playerTarget;
              }
          }

          // Move these lines inside the loop where result is defined
          const holesPlayed = result.endExclusive - result.startInclusive;
          const expectedTeamPoints = (teamTarget / pars.length) * holesPlayed;

          // Apply color for team points
          applyPerformanceColor(teamPointsCell, pointsTeam, expectedTeamPoints, "higher");

          // TEAM NET
          let netTeam = 0;
          for (let currPlayerIndex = 0; currPlayerIndex < numPlayers; currPlayerIndex++) {
              const playerNetOrNaN = parseFloat(
                  document.getElementById(idResultNetPlayer(result.name, currPlayerIndex)).textContent
              );
              if (!isNaN(playerNetOrNaN)) {
                  netTeam += playerNetOrNaN;
              }
          }

          const netTeamCell = document.getElementById(idResultNetTeam(result.name));
          netTeamCell.textContent = netTeam;

          // Apply color for team net (goal is to stay close to 0 or positive)
          applyPerformanceColor(netTeamCell, netTeam, 0, "higher");
      }
  }

function updateResult(result, pars, playerIndex, score, points) {
    const holeIndices = Array.from(
        { length: result.endExclusive - result.startInclusive },
        (_, i) => result.startInclusive + i
    );

    const rawScores = score.scores;
    console.log(`Player ${playerIndex} - Raw Scores:`, rawScores);

    const playedHoles = holeIndices.filter(i => {
        const val = rawScores[i];
        return val !== "" && !isNaN(parseFloat(val));
    });

    console.log(`Hole Indices for result:`, holeIndices);
    console.log(`Played Holes in result range:`, playedHoles);

    const resultScore = sumNumbersByIndex(score.scores, holeIndices);
    const resultPoints = sumNumbersByIndex(points.points, holeIndices);

    const scoreCell = document.getElementById(idResultScorePlayer(result.name, playerIndex));
    const pointsCell = document.getElementById(idResultPointsPlayer(result.name, playerIndex));
    const netCell = document.getElementById(idResultNetPlayer(result.name, playerIndex));

    scoreCell.textContent = resultScore;
    pointsCell.textContent = resultPoints;

    const resultNet = computeNet(points, pars, holeIndices, playerIndex);
    netCell.textContent = resultNet;

    const targetPoints = parseInt(document.getElementById(idTarget(playerIndex)).value);
    const expectedPoints = (targetPoints / pars.length) * holeIndices.length;
    const expectedNet = 0;

    console.log(`Player ${playerIndex} - Points: ${resultPoints}, Expected Points: ${expectedPoints}`);
    console.log(`Player ${playerIndex} - Net: ${resultNet}, Expected Net: ${expectedNet}`);

    applyPerformanceColor(pointsCell, resultPoints, expectedPoints, "higher");
    applyPerformanceColor(netCell, resultNet, expectedNet, "higher");
}





  function computeScore(numHoles, playerIndex) {
      let scores = [];
      let total = 0;
      for (let holeIndex = 0; holeIndex < numHoles; holeIndex++) {
          const rawScore = document.getElementById(idHolePlayer(holeIndex, playerIndex)).value;
          scores.push(rawScore);

          const score = parseInt(rawScore);
          if (isNaN(score)) {
              continue;
          }
          total += score;
      }
      return { "overall_score": total, "scores": scores };
  }

  function computePoints(pars, playerIndex) {
      let scoresOrNaN = [];
      for (let holeIndex = 0; holeIndex < pars.length; holeIndex++) {
          scoresOrNaN.push(parseInt(document.getElementById(idHolePlayer(holeIndex, playerIndex)).value));
      }

      // We need to compute points iff the user has entered a value for the corresponding hole.

      let points = [];
      let total = 0;
      for (let holeIndex = 0; holeIndex < pars.length; holeIndex++) {
          if (isNaN(scoresOrNaN[holeIndex])) {
              points.push("");
              continue;
          }

          const point = Math.max(0, 2 - (scoresOrNaN[holeIndex] - pars[holeIndex]));
          points.push(point);
          total += point;
      }
      return { "overall_points": total, "points": points };
  }

  function computeNet(points, pars, holeIndices, playerIndex) {
    const targetOrNaN = parseInt(document.getElementById(idTarget(playerIndex)).value);

    if (isNaN(targetOrNaN)) {
        return "";
    }

    const resultTarget = targetOrNaN * (holeIndices.length / pars.length);
    const resultPoints = sumNumbersByIndex(points.points, holeIndices);
    const net = resultPoints - resultTarget;

    return Math.round(net * 10) / 10;
}


  function sumNumbersByIndex(numbersOrNaN, indices) {
      let out = 0;
      for (let index of indices) {
          const numOrNaN = parseInt(numbersOrNaN[index]);
          if (isNaN(numOrNaN)) {
              continue;
          }
          out += numOrNaN;
      }
      return out;
  }

  function updateTeamTarget(numPlayers) {
      let total = 0;
      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const possibleTarget = parseInt(document.getElementById(idTarget(playerIndex)).value);
          if (isNaN(possibleTarget)) {
              continue;
          }
          total += possibleTarget;
      }

      document.getElementById("team_target").textContent = total;
  }


  function lockInputs() {
      const localSpreadsheetConfig = spreadsheetConfig();

      const submitButton = document.getElementById("submit_button");
      submitButton.disabled = true;

      const teamInput = document.getElementById("team");
      teamInput.disabled = true;

      // For now we hardcode that at most 4 players per team.
      for (let playerIndex = 0; playerIndex < 4; playerIndex++) {

          const possiblePlayerName = document.getElementById(idPlayerName(playerIndex));
          const possiblePlayerTarget = document.getElementById(idTarget(playerIndex));

          if (possiblePlayerName == null) {
              break;
          }

          possiblePlayerName.disabled = true;
          possiblePlayerTarget.disabled = true;

          for (let holeIndex = 0; holeIndex < localSpreadsheetConfig.courseConfig.pars.length; holeIndex++) {
              const possibleInput = document.getElementById(idHolePlayer(holeIndex, playerIndex));
              if (possibleInput == null) {
                  break;
              }
              possibleInput.disabled = true;
          }
      }

      // Set the lock flag to true
      inputsLocked = true;
      console.log("Inputs locked:", inputsLocked);
  }




function submit() {
  clearInterval(saveInterval);

  const submitBtn = document.getElementById("submit_button");
  const originalText = submitBtn.textContent;
  submitBtn.classList.add("loading");
  submitBtn.textContent = "Submitting...";

  const localSpreadsheetConfig = spreadsheetConfig();
  const selectedTeamConfig = getSelectedTeamConfig(localSpreadsheetConfig.allTeamConfigs);
  const courseName = localSpreadsheetConfig.courseConfig.courseName;
  const pars = localSpreadsheetConfig.courseConfig.pars;
  const numHoles = pars.length;
  const currentTeamName = document.getElementById("team").value;
  const date = document.getElementById("date").textContent;

  let flatResults = [];
  let allScoresEntered = true;

  selectedTeamConfig.players.forEach((_, playerIndex) => {
    const playerNameEl = document.getElementById(idPlayerName(playerIndex));
    const playerName = playerNameEl.value;
    if (!playerName) return;

    const playerStats = [date, currentTeamName, courseName, playerName];
    for (let holeIndex = 0; holeIndex < numHoles; holeIndex++) {
      const score = document.getElementById(idHolePlayer(holeIndex, playerIndex)).value;
      playerStats.push(score);
      if (score === "") allScoresEntered = false;
    }
    playerStats.push(document.getElementById(idTarget(playerIndex)).value);
    for (const result of RESULTS) {
      playerStats.push(document.getElementById(idResultScorePlayer(result.name, playerIndex)).textContent);
      playerStats.push(document.getElementById(idResultPointsPlayer(result.name, playerIndex)).textContent);
      playerStats.push(document.getElementById(idResultNetPlayer(result.name, playerIndex)).textContent);
    }
    flatResults.push(playerStats);
  });

  const teamStats = [date, currentTeamName, courseName, currentTeamName];
  teamStats.push(...Array(numHoles).fill(""));
  teamStats.push(document.getElementById("team_target").textContent);
  for (const result of RESULTS) {
    teamStats.push("");
    teamStats.push(document.getElementById(idResultPointsTeam(result.name)).textContent);
    teamStats.push(document.getElementById(idResultNetTeam(result.name)).textContent);
  }
  flatResults.push(teamStats);

  let message =
    "Be sure all scores are correct! When so, click 'OK' to SUBMIT these scores.\n\n" +
    "Thanks!\n\n" +
    "A Green pop‚Äêup Submit & Email Success message indicates a successful submission.\n\n";
  if (!allScoresEntered) {
    message +=
      "Wait -- I see some holes without scores -- please 'Cancel' and fully fill in scores!\n\n";
  }
  message +=
    "With V. 5.0 and beyond, now each player will get an email of the submitted scorecard immediately upon a successful submission!";
  if (!confirm(message)) {
    submitBtn.classList.remove("loading");
    submitBtn.textContent = originalText;
    return;
  }

  google.script.run.recordScorerActivity({
    teamName: currentTeamName || "Unknown",
    playerName: scoreKeeper || "Unknown",
    activity: "Submitter"
  });

  const saveArray = selectedTeamConfig.players.map((_, playerIndex) => {
    const name = document.getElementById(idPlayerName(playerIndex)).value;
    const target = document.getElementById(idTarget(playerIndex)).value;
    const holeScores = [];
    for (let holeIndex = 0; holeIndex < numHoles; holeIndex++) {
      holeScores.push(document.getElementById(idHolePlayer(holeIndex, playerIndex)).value);
    }
    return [name, target, ...holeScores];
  });

  console.log("Saving before submitting:", JSON.stringify(saveArray));

  google.script.run
    .withSuccessHandler(() => {
      localStorage.setItem("savedScores", JSON.stringify(saveArray));
      const now = new Date();
      const time = now.getHours().toString() + ":" + now.getMinutes().toString().padStart(2, "0");
      document.getElementById("save_status").innerHTML = "<b><i>Saved at</i></b> " + time;
    })
    .withFailureHandler((error) => {
      const statusElem = document.getElementById("save_status");
      statusElem.textContent = "Failed to Save";
      statusElem.style.cssText = "font-size: 40px; font-weight: bold; color: red;";
      console.error("Error saving scores:", error);
    })
    .saveScoresForTeam(currentTeamName, saveArray);

  lockInputs();

  console.log("scoreKeeper being passed to server:", scoreKeeper);

  google.script.run
    .withSuccessHandler(function (serverLogs) {
      if (showServerLogs) {
        serverLogs.forEach((line) => console.log("Server:", line));
      }

      const teamKey = `autosaveDisabledDate_${currentTeamName}`;
      const today = new Date().toISOString().slice(0, 10);
      localStorage.setItem(teamKey, today);
      window.autoSaveManuallyDisabled = true;

      const autoSaveStatus = document.getElementById("autosave_status");
      if (autoSaveStatus) {
        autoSaveStatus.innerHTML = "<b>Auto-save disabled for today (scores already submitted)</b>";
        autoSaveStatus.style.color = "red";
      }

      console.log(`‚úÖ Submit successful ‚Äî autosaveDisabledDate set for ${currentTeamName}:`, today);
      console.log("autoSaveManuallyDisabled after submit:", window.autoSaveManuallyDisabled);

      const confirmEl = document.getElementById("submit_confirmation");
      confirmEl.textContent = "Submit & Email Success - Thanks!";
      confirmEl.style.cssText = "font-size: 40px; font-weight: bold; color: green;";
      const utterance = new SpeechSynthesisUtterance("Submit & Email Success - Thanks!");
      utterance.rate = 1.0;
      window.speechSynthesis.speak(utterance);

      forceLock = true;
      inputsLocked = true;

      document.querySelectorAll("input, select, button").forEach((el) => {
        if (el.id !== "refresh-btn") el.disabled = true;
      });

      const disableAndDim = (id) => {
        const btn = document.getElementById(id);
        if (btn) {
          btn.disabled = true;
          btn.style.opacity = "0.5";
        }
      };
      disableAndDim("submit_button");
      disableAndDim("clear_button");

      // ‚úÖ Reset button state
      submitBtn.classList.remove("loading");
      submitBtn.textContent = originalText;
    })
    .withFailureHandler((error) => {
      const confirmEl = document.getElementById("submit_confirmation");
      confirmEl.textContent = "Failed, re-start App, pull up your tee time, and re-submit.";
      confirmEl.style.cssText = "font-size: 40px; font-weight: bold; color: red;";
      const utterance = new SpeechSynthesisUtterance(confirmEl.textContent);
      utterance.rate = 1.0;
      window.speechSynthesis.speak(utterance);

      console.error("Submission failed:", error);

      // ‚ùå Reset button state on failure too
      submitBtn.classList.remove("loading");
      submitBtn.textContent = originalText;
    })
    .saveData(flatResults, scoreKeeper || "Unknown");
}



  function clearWithConfirmation() {
      if (confirm("Be VERY sure you want to clear the hole scores!")) {
          clearScoresAndCache();
      }
  }


  function clearScoresAndCache() {
      const localSpreadsheetConfig = spreadsheetConfig();
      const selectedTeamConfig = getSelectedTeamConfig(localSpreadsheetConfig.allTeamConfigs);

      // For now we hardcode that at most 4 players per team.
      for (let playerIndex = 0; playerIndex < 4; playerIndex++) {
          for (let holeIndex = 0;
              holeIndex < localSpreadsheetConfig.courseConfig.pars.length;
              holeIndex++) {
              const possibleInput = document.getElementById(idHolePlayer(holeIndex, playerIndex));
              if (possibleInput == null) {
                  break;
                  }
                possibleInput.value = ""; // Set to empty string
                possibleInput.style.backgroundColor = "yellow"; // Set background color to yellow when empty
              }
      }

      localStorage.clear();

      // Basically just resets everything to empty
      updateAllStats(
          RESULTS,
          localSpreadsheetConfig.courseConfig.pars,
          selectedTeamConfig.players.length);
  }


  function clearScoresAndCacheForPlayer(playerIndex) {
    const localSpreadsheetConfig = spreadsheetConfig();
    const selectedTeamConfig = getSelectedTeamConfig(localSpreadsheetConfig.allTeamConfigs);

    for (let holeIndex = 0; holeIndex < localSpreadsheetConfig.courseConfig.pars.length; holeIndex++) {
      const possibleInput = document.getElementById(idHolePlayer(holeIndex, playerIndex));
      if (possibleInput == null) {
        break;
      }
      possibleInput.value = ""; // Set to empty string
      possibleInput.style.backgroundColor = "yellow"; // Set background color to yellow when empty
    }


    // Update stats for the remaining players
    updateAllStats(
      RESULTS,
      localSpreadsheetConfig.courseConfig.pars,
      selectedTeamConfig.players.length
    );
  }


  function idHoleRow(holeIndex) {
      return "holeRow_" + holeIndex;
  }

  function idHolePlayer(holeIndex, playerIndex) {
      return holeIndex + "_" + playerIndex;
  }

  function idResultScorePlayer(resultName, playerIndex) {
      return "result_" + resultName + "_score_" + playerIndex;
  }

  function idResultPointsPlayer(resultName, playerIndex) {
      return "result_" + resultName + "_points_" + playerIndex;
  }

  function idResultPointsTeam(resultName) {
      return "result_" + resultName + "_points_team";
  }

  function idPlayerName(playerIndex) {
      return "name_" + playerIndex;
  }

  function idTarget(playerIndex) {
      return "target_" + playerIndex;
  }

  function idResultNetPlayer(resultName, playerIndex) {
      return "result_" + resultName + "_net_" + playerIndex;
  }

  function idResultNetTeam(resultName) {
      return "result_" + resultName + "_net_team";
  }
 

   // Obfucation end - if desired

  </script>

</body>

</html>
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>‚õ≥Ô∏èüèåÔ∏è‚Äç‚ôÇÔ∏èüìù</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 20px; /* Ensuring padding for all sides */
      box-sizing: border-box;
      background-color: #ADD8E6;
      font-size: 1.2em;  /* Set a base font size */
      line-height: 1.5em; /* Improve readability */
      scroll-behavior: smooth;
    }


    h1 {
      font-size: 2.2em;
      /* Adjust the size as needed */
      margin-top: 0;
      /* Ensure no margin at the top */
    }

    h2 {
      color: blue;
      font-weight: bold;
      font-style: italic;
      padding-left: 0.25in; /* Adds 1/2 inch padding on the left */
      text-align: left; /* Aligns text to the left */
      font-size: 1.4em; /* Adjust base font size */
    }


    #title {
      font-size: 1em;
      color: blue;
      font-weight: bold;
      margin-bottom: 20px;
    }


    #instructions {
    margin: 1em 0; /* Adding margin to the top and bottom */
    font-size: 1.3em; /* Set font size to 1.6em */
    }

    /* Sticky header class -- keeps names at top when scrolling down */
    .sticky-header {
      position: sticky;
      top: 0; /* Sticky position at the top */
      background-color: #ADD8E6;   /* Background color to distinguish header */
      z-index: 1000; /* Ensure it's on top of other content */
      font-size: 1.5em; /* Set font size */
      font-weight: bold;   /* Set font weight */
    }

    /* Styling for the refresh and scoreboard buttons */
    #refresh-btn,
    #scoreboard_button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 1.5em;
      background-color: green;
      color: white;
      border: none;
      cursor: pointer;
    }

    #refresh-btn:hover,
    #scoreboard_button:hover {
      background-color: darkgreen;
    }

    button.loading {
      position: relative;
      opacity: 0.6;
      pointer-events: none;
    }

    button.loading::after {
      content: "";
      position: absolute;
      right: 10px;
      top: 50%;
      width: 18px;
      height: 18px;
      margin-top: -9px;
      border: 3px solid #fff;
      border-top: 3px solid #333;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .image-container {
        display: flex;
        justify-content: flex-start;
        margin-left: 3%; /* the margin to 3% from the left */
        gap: 30px; /* gap between the images as needed */
    }
    .image-container img {
       width: 200px; /* Set the desired width for both images */
        height: auto; /* Maintain aspect ratio */
    }


  /* Common styles for all tables' td */
  #scoreboardAB-table td,
  #scoreboardCD-table td,
  #scoreboardTeam-table td {
    font-size: 2em;
    padding: 6px;
    text-align: center;
    vertical-align: middle;
  }

  /* Table layout */
  #scoreboardAB-table,
  #scoreboardCD-table,
  #scoreboardTeam-table {
    width: auto;
    border-collapse: collapse;
  }

  /* Table headers */
  #scoreboardAB-table th,
  #scoreboardCD-table th,
  #scoreboardTeam-table th {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
    border: 1px solid #ccc;
    font-size: 1.7em;
    background-color: #f0f0f0;
    color: black;
    font-weight: bold;
  }

  /* First column styling */
  /* Team names in Team table */
  #scoreboardTeam-table td:first-child {
    color: blue;
    font-weight: bold;
  }

  /* Scores in first column of AB and CD tables */
  #scoreboardAB-table td:first-child,
  #scoreboardCD-table td:first-child {
    color: black;
    font-weight: bold;
  }

  /* Player names in second column of AB and CD tables */
  #scoreboardAB-table td:nth-child(2),
  #scoreboardCD-table td:nth-child(2) {
    color: blue;
    font-weight: bold;
  }

  /* Bold scores columns in Team table (2nd and onwards) */
  #scoreboardTeam-table td:nth-child(n+2) {
    font-weight: bold;
  }

  /* Highlight max scores */
  .highlight-max {
    background-color: yellow;
  }

  /* Common table cell styles */
  #scoreboardAB-table td,
  #scoreboardCD-table td,
  #scoreboardTeam-table td {
    font-size: 2em;
    padding: 6px;
    text-align: center;
    vertical-align: middle;
  }

  /* Table layout */
  #scoreboardAB-table,
  #scoreboardCD-table,
  #scoreboardTeam-table {
    width: auto;
    border-collapse: collapse;
  }

  /* Table headers */
  #scoreboardAB-table th,
  #scoreboardCD-table th,
  #scoreboardTeam-table th {
    text-align: center;
    vertical-align: middle;
    padding: 6px;
    border: 1px solid #ccc;
    font-size: 1.7em;
    background-color: #f0f0f0;
    color: black;
    font-weight: bold;
  }

  /* First column styling */
  #scoreboardTeam-table td:first-child {
    color: blue;
    font-weight: bold;
  }

  #scoreboardAB-table td:first-child,
  #scoreboardCD-table td:first-child {
    color: black;
    font-weight: bold;
  }

  #scoreboardAB-table td:nth-child(2),
  #scoreboardCD-table td:nth-child(2) {
    color: blue;
    font-weight: bold;
  }

  /* Bold scores columns in Team table */
  #scoreboardTeam-table td:nth-child(n+2) {
    font-weight: bold;
  }

  /* Highlight max scores */
  .highlight-max {
    background-color: yellow;
  }

  /* More specific color classes inside AB and CD tables */
  #scoreboardAB-table td.label-par,
  #scoreboardCD-table td.label-par {
    color: black !important;
  }

  #scoreboardAB-table td.label-birdie,
  #scoreboardCD-table td.label-birdie {
    color: #006400 !important; /* dark green */
  }

  #scoreboardAB-table td.label-eagle,
  #scoreboardCD-table td.label-eagle {
    color: #CC8400 !important; /* darker orange */
  }

  #scoreboardAB-table td.label-albatross,
  #scoreboardCD-table td.label-albatross {
    color: #2A5179 !important; /* deep cyan with purple undertones */
  }


  </style>

</head>


<body>

  <audio id="audio" src="https://www.dropbox.com/scl/fi/666kzmgv2f3t6c1alhx1g/startup-sound.mp3?rlkey=isnzy1syfswgg5p3n2gskz1zp&st=5ryggmm7&raw=1" type="audio/mpeg"></audio>


    <div class="image-container">
        <img src="https://live.staticflickr.com/65535/54259105499_43c986c7ea_z.jpg" alt="GoogleGolf Scoring System Logo">
        <img src="https://live.staticflickr.com/65535/54033042787_0126e057cd_w_d.jpg" alt="BT Logo">
    </div>

<br>

  <!-- yes, the below spacing is not elegant-- but found necessary to keep all parts aligned -- especially the Delete Player boxes -->

  <div id="title">
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Your Google-Based DIY Golf Group <br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scoring System<br> 
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>V. 7.4</b><br>
  </div>

  <div id="course" style="display: inline-block; font-size: 1.75em; font-weight: bold;"></div>

  <div id="all_input">
    <div>
        <div style="display: inline-block; font-size: 1.75em; font-weight: bold;">Date: </div>
        <div style="display: inline-block; font-size: 1.75em; font-weight: bold;" id="date"></div>
    </div>
    </div>
    <div>
        <div style="display: inline-block; font-size: 1.75em;">
            <font color="Blue"><b>Tee Time: </b></font>
            <select style="display: inline-block; font-size: 1em; padding: 5px 5px; width: 8ch" id="team" placeholder= "Select">
                <option value="" disabled selected>Select</option>
            </select>
        </div>
    </div>
    <div id="team_options"></div>
    <div style="display: inline-block; font-size: 1.75em;"><b>Team Target Points =  </b></div>
    <div style="display: inline-block; font-size: 1.75em; font-weight: bold;" id="team_target"></div>
</div> 


<br>
<div id="table"></div>
<div id="buttons">
<table>
    <tr></tr>
    <tr></tr>
    <tr></tr>
<br>
  <!-- Scoreboard Use Only Button (now dark green) -->
    <tr>
        <td>
            <button id="scoreboard_button" onclick="scoreboardOnly()">
                Scoreboard Use Only
            </button>
        </td>
    </tr>

    <!-- Spacer Row for Vertical Space -->
    <tr>
        <td style="height: 40px;"></td> <!-- Adjust height as needed -->
    </tr>
    <!-- Submit Button Row (indented about 1/2 inch) -->
    <tr>
        <td style="padding-left: 0.5in;">
            <button id="submit_button" onclick="submit()" disabled="true"
                        style="color: green; font-size: 30px; padding: 10px 10px">
                        Submit & Email
            </button>
        </td>
        <td>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <div id="submit_confirmation"></div>
        </td>
    </tr>

    <!-- Spacer rows between Submit & Clear -->
 
    <tr></tr>
    <tr></tr>
    <tr></tr>

    <!-- Clear Button Row -->
    <tr>
        <td></td>
        <td></td>
        <td>
            <button id="clear_button" onclick="clearWithConfirmation()" disabled="true" style="color:red; font-size: 30px; padding: 10px 10px">
                Clear
            </button>
        </td>
    </tr>
</table>


</div>


  <div id="table"></div>

  <tr></tr>
  <tr></tr>
  <tr></tr>


<button id="refresh-btn">Refresh Scoreboards</button>
<br>


<p style="color: red; font-size: 1.5em; font-style: italic; font-weight: bold; display: inline-block;">
  <span style="display: block; text-align: center;">
    Auto-Refreshes every 30 sec.
  </span>
  <span>
    Pre-Results & Constantly Changing Until All Scores are In!
  </span>
</p>


<table id="scoreboardAB-table">
  <thead>
    <tr>
      <th style="width:400px; font-size: 2em;">AB Skins</th>
      <th style="width:400px; font-size: 2em;">Player</th>  
    </tr>
  </thead>
  <tbody id="scoreboardAB-body"></tbody>
</table>

<br><br>

<table id="scoreboardCD-table">
  <thead>
    <tr>
      <th style="width:400px; font-size: 2em;">CD Skins</th>
      <th style="width:400px; font-size: 2em;">Player</th>
    </tr>
  </thead>
  <tbody id="scoreboardCD-body"></tbody>
</table>

<br><br>

<p style="color: red; font-size: 1.5em; font-style: italic; font-weight: bold; margin-left: 110px;">
  No ¬±2 Corrections in these team scores.
</p>

<table id="scoreboardTeam-table">
  <thead>
    <tr>
      <th style="width:225px; font-size: 2em;">Teams</th>
      <th style="width:175px; font-size: 2em;">Front Net</th>
      <th style="width:175px; font-size: 2em;">Back Net</th>
      <th style="width:175px; font-size: 2em;">Total Net</th>
    </tr>
  </thead>
  <tbody id="scoreboardTeam-body"></tbody>
</table>

    <br>
    <br>

    <div style="margin-left: 1in; margin-bottom: 20px;">
      <button
        onclick="location.href='https://tinyurl.com/springfieldgolfsignup'"
        style="margin-top: 20px; padding: 10px 20px; font-size: 1.5em; color: red; font-weight: bold; background-color: white; border: none; cursor: pointer;">
        Signup for Playing Future Days
      </button>
    </div>






    </div>

    <br>

    <p id="instructions">
    <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>Instructions</u></b><br>
            Choose your scheduled Tee Time, input all 
            scores. The App does auto-saves all of your 
            scores every ~25 secs, if problems, 
            re-select your Tee Time & hit "Reload" 
            to regain your scores.</b><b>  If a player drops out, 
            delete the player via the "Delete Player" top boxes-- 
            this deletes all of his data.</b> Then all remaining 
            team points are correct. When ready, use the <span style="font-weight: bold; color: green;">"Submit and Email" </span>
            button to send your scores in and now all players will receive emails with the scorecard. 
            You will see a confirmation of <span style="font-weight: bold; color: green;">"Submit & Email Success - Thanks!" </span> 
            if successful.  If you get a Failure message, restart the App, bring up your tee time/scores, try again. <b>Then you are done!</b><br>
    <br>
            Note: <span style="font-weight: bold; color: red;">"Clear"</span> clears all scores.
    <br><br>
                <span style="background-color: cyan"><b>Albatrosses</b></span>, &nbsp;<span
                style="background-color: orange"><b>Eagles</b></span>, &nbsp;<span
                style="background-color: green"><b> Birdies</b></span>, &nbsp;<span style="background-color: #A9A9A9"><b>Pars</b></span>, & &nbsp;
                <span style="background-color: #D3D3D3"><b>Bogeys</b></span>. &nbsp; <b><i> are highlighted.</b></i>
          </p>


  <script>
  

  document.addEventListener("DOMContentLoaded", function () {
    document.addEventListener("click", function playOnce() {
      const audio = document.getElementById("audio");
      if (audio) {
        audio.play().catch(function (error) {
          console.error("Audio playback failed:", error);
        });
      } else {
        console.warn("Audio element not found.");
      }
      document.removeEventListener("click", playOnce);
    });
  });

  

// Window positioning and tailoring to Mobile and Android -- may need to add for others. 

  window.addEventListener('load', function() {
          // Scroll to top on page load
          window.scrollTo(0, 0);
      });



  document.addEventListener("DOMContentLoaded", function () {
    const isMobile = /Mobi/i.test(navigator.userAgent);
    const isAndroid = /Android/i.test(navigator.userAgent);
    const teamInput = document.getElementById("team");

    // Ensure elements exist before modifying them
    const title = document.getElementById("title");
    const course = document.getElementById("course");
    const instructions = document.getElementById("instructions");

    if (isMobile && !isAndroid) {
        // Set readonly for mobile devices (excluding Android)
        if (teamInput) teamInput.readOnly = true;
        document.body.style.zoom = "1.0"; // No zoom for iPhones
    } else if (isAndroid) {
        // Settings for Android devices
        if (teamInput) {
            teamInput.readOnly = false;
            teamInput.style.width = "12ch"; // Set width to 12ch for Android devices
        }
        
        document.body.style.zoom = "1"; // Keep same zoom for Android devices

        // Reduce font size for Android devices
        if (title) title.style.fontSize = "0.3em";
        //if (course) course.style.fontSize = "0.25em";
        if (instructions) instructions.style.fontSize = "0.4em";
    } else {
        // Settings for non-mobile devices (desktop)
        if (teamInput) {
            teamInput.readOnly = false;
            teamInput.style.width = "12ch"; // Set width to 12ch for desktop devices
        }
        document.body.style.zoom = "0.5"; // Zoom out for desktop devices
    }
  });


  document.addEventListener("DOMContentLoaded", () => {
    startKeepAlivePing();
  });

  document.addEventListener("DOMContentLoaded", () => {
    startAutoRefresh();   // ‚úÖ auto-refresh always starts when page loads
  });

  window.onload = () => {
    initializeAutoSaveFlag();
    // Other init code like createSaveLoadButtons(), etc.
  };


  // === WATCH ONLY ADD ===
  let watchOnlyActive = false;
  let watchOnlyInterval = null;



    // Initialize the flag from localStorage-- to use later for diabling auto save after a submission for the day
  function initializeAutoSaveFlag() {
    const today = new Date().toISOString().slice(0, 10);
    const disabledDate = localStorage.getItem("autosaveDisabledDate");

    if (disabledDate === today) {
      window.isSavingDisabled = true;
      autoSaveSkipNotified = true;
      const autoSaveStatus = document.getElementById("autosave_status");
      if (autoSaveStatus) {
        autoSaveStatus.innerHTML = "<b><i>Auto-save disabled for today (scores already submitted)</i></b>";
        autoSaveStatus.style.color = "red";
      }
    } else {
      window.isSavingDisabled = false;
      autoSaveSkipNotified = false;
    }
  }


  function startKeepAlivePing() {
    if (!window.pingIntervalId) {
      console.log("üîÑ Starting keep-alive ping every 4 minutes...");
      window.pingIntervalId = setInterval(() => {
        console.log("üì° Sending keep-alive ping to server...");
        google.script.run
          .withFailureHandler(error => console.log("‚ùå Ping failed:", error))
          .withSuccessHandler(response => console.log("‚úÖ Ping response:", response))
          .pingServer();
      }, 4 * 60 * 1000); // every 4 minutes
    }
  }

  // Automatically start on page load (or move into a user action)
  document.addEventListener("DOMContentLoaded", () => {
    startKeepAlivePing();
  });



//Par Info -- setting Max and Min scores for each hole-- Important, ensure the below "score" functions have the same values

    // Function to calculate minScore -- needs to mimic same as getUserScore()'s value, too
  function getMinScore(par) {
    return Math.max(par - 3, 1); // this is an Albatross, but 1 for Par 3's
  }

  // IMPORTANT - NEED TO SET MAX SCORE IN 2 PLACES BELOW AS THE SAME
    // Function to calculate maxScore  -- needs to mimic same as getUserScore()'s value, too
  function getMaxScore(par) {
     return par + 2; // for double bogey max
    // return par + 3; // for double bogey max
    //return par * 2; // for 2x par max
  }

  function getUserScore(value, par) {
    let userScore = value;
    if (userScore === null || userScore === "") {
        return "";
    }
        // This sets the MAX Score for a Player,  Watch out, "66" < "7", so we use Math functions explicitly.
        // defualt is double bogey max = par +2,  easy to change below ...
     userScore = Math.min(userScore, par + 2); // double bogey is max score
    // userScore = Math.min(userScore, par + 3);  // if you want triple bogey as max
    //userScore = Math.min(userScore, 2 * par);  // if you want 2 x par as max
    
           // This sets the Min Score for a Player
    userScore = Math.max(userScore, Math.max(par - 3, 1)); // this is an Albatross, but 1 smallest -- for Par 3's

    return userScore;
  }


// setting of color highlights score within App based on holes' par
  function getHoleForPlayerColor(userScore, par) {
      // Color 2xBogey or greater = white (no points), bogey or better = shaded to denote points for that hole 
      if (parseInt(userScore) >= (par + 2)) {
          return "#FFFFFF"; // White
      }
      if (parseInt(userScore) >= (par + 1)) {
          return "#D3D3D3"; // Light Gray
      }     
      if (parseInt(userScore) === (par)) {
          return "#A9A9A9"; // Dark Gray
      }            
      if (parseInt(userScore) === (par - 1)) {
          return "#90EE90"; // Green
      }
      if (parseInt(userScore) === (par - 2)) {
          return "#FFA500"; // Orange
      }
      if (parseInt(userScore) === (par - 3)) {
          return "#00FFFF"; // Cyan
      }
      return "";
  }


 // obfuscation start -- if desired


      // global variables to affect the auto saving periods, locks, notifications
    let scoreboardOnlyActive = false;
    let initialDelaySec = 15;
    let saveIntervalSec = 25;
    let saveInterval = null;
    let inputsLocked = false; 
    let forceLock = false;
    let autoSaveSkipNotified = false;  // Global flag to track disabling of auto save notification shown once
    let showServerLogs = true;  // make true to see some server side msgs from the Submit function

    let hasPlayed = false; // Variable to track if the startup sound has already been played

    let scoreboardAutoRefresh = null;


    function startAutoRefresh() {
      if (!scoreboardAutoRefresh) {
        scoreboardAutoRefresh = setInterval(() => {
          console.log("Auto-refreshing scoreboards...");
          refreshScoreboards();
        }, 30000); // every 30 seconds
      }
    }


       // only for testing
    function resetAllAutoSaveFlags() {
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith("autosaveDisabledDate_")) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(key => localStorage.removeItem(key));
      console.log(`üö© Reset auto-save flags for teams: ${keysToRemove.join(", ")}`);
    }


    //resetAllAutoSaveFlags();    // only for testing

/**
  function scoreboardOnly() {
    scoreboardOnlyActive = true;
    forceLock = true;
    inputsLocked = true;

    // Disable all inputs except refresh
    const inputs = document.querySelectorAll("input, select, button");
    inputs.forEach(el => {
      if (el.id !== "refresh-btn") {
        el.disabled = true;
      }
    });

    // Disable team selection
    const teamSelect = document.getElementById("team");
    if (teamSelect) {
      teamSelect.onchange = null;
      teamSelect.disabled = true;

      // Optionally just hide the row instead of removing it
      const teamContainer = teamSelect.closest("div");
      if (teamContainer) {
        teamContainer.style.display = "none";
      }
    }

    // Hide team options div if present
    const teamOptions = document.getElementById("team_options");
    if (teamOptions) {
      teamOptions.style.display = "none";
    }

    // Hide team target display
    const teamTarget = document.getElementById("team_target");
    if (teamTarget) {
      teamTarget.style.display = "none";
    }

    // Clear the dynamic table
    const tableDiv = document.getElementById("table");
    if (tableDiv) {
      tableDiv.innerHTML = "";
    }

    // Remove the Scoreboard Use Only button itself
    const scoreboardBtn = document.getElementById("scoreboard_button");
    if (scoreboardBtn) {
      scoreboardBtn.remove();
    }

    // Remove Submit & Email button
    const submitBtn = document.getElementById("submit_button");
    if (submitBtn) {
      submitBtn.remove();
    }

    // Remove Clear button
    const clearBtn = document.getElementById("clear_button");
    if (clearBtn) {
      clearBtn.remove();
    }

    console.log("Scoreboard Use Only fully activated: UI frozen, elements hidden or removed.");
  }
*/

function scoreboardOnly() {
  scoreboardOnlyActive = true;
  forceLock = true;
  inputsLocked = true;

  // Disable all inputs except refresh
  const inputs = document.querySelectorAll("input, select, button");
  inputs.forEach(el => {
    if (el.id !== "refresh-btn") {
      el.disabled = true;
    }
  });

  // Disable team selection
  const teamSelect = document.getElementById("team");
  if (teamSelect) {
    teamSelect.onchange = null;
    teamSelect.disabled = true;

    // Optionally just hide the row instead of removing it
    const teamContainer = teamSelect.closest("div");
    if (teamContainer) {
      teamContainer.style.display = "none";
    }
  }

  // Hide team options div if present
  const teamOptions = document.getElementById("team_options");
  if (teamOptions) {
    teamOptions.style.display = "none";
  }

  // Hide team target display
  const teamTarget = document.getElementById("team_target");
  if (teamTarget) {
    teamTarget.style.display = "none";
  }

  // Clear the dynamic table
  const tableDiv = document.getElementById("table");
  if (tableDiv) {
    tableDiv.innerHTML = "";
  }

  // Remove the Scoreboard Use Only button itself
  const scoreboardBtn = document.getElementById("scoreboard_button");
  if (scoreboardBtn) {
    scoreboardBtn.remove();
  }

  // Remove Submit & Email button
  const submitBtn = document.getElementById("submit_button");
  if (submitBtn) {
    submitBtn.remove();
  }

  // Remove Clear button
  const clearBtn = document.getElementById("clear_button");
  if (clearBtn) {
    clearBtn.remove();
  }

  console.log("Scoreboard Use Only fully activated: UI frozen, elements hidden or removed.");

}




function watchOnlyMode() {
  console.log("‚ñ∂ Watch Only Mode activated");
  window.watchOnlyActive = true;

  const disableInputs = () => {
    const inputs = document.querySelectorAll("#table input, #table textarea, #table select");
    inputs.forEach(inp => {
      inp.disabled = true;
      inp.style.cursor = "not-allowed";
    });

    const saveButtons = document.querySelectorAll(".save-load-buttons button, .save-button-bottom button");
    saveButtons.forEach(btn => {
      btn.disabled = true;
      btn.style.cursor = "not-allowed";
    });
  };

  const submitBtn = document.getElementById("submit_button");
  if (submitBtn) submitBtn.remove();

  const clearBtn = document.getElementById("clear_button");
  if (clearBtn) clearBtn.remove();

  const deletePlayerContainers = document.querySelectorAll("div");
  deletePlayerContainers.forEach(div => {
    const bTag = div.querySelector("b");
    if (bTag && bTag.textContent.includes("Delete Player")) {
      div.remove();
    }
  });

  const statusEl = document.getElementById("autosave_status_top");
  if (statusEl) {
    statusEl.innerHTML = "<b>Watch Only Mode - auto-reloading</b>";
    statusEl.style.color = "orange";
  }

  if (window.saveInterval) {
    clearInterval(window.saveInterval);
    window.saveInterval = null;
  }


  function reloadScores() {
    const teamName = document.getElementById("team")?.value;
    if (!teamName) return;

    console.log("üîÑ [DEBUG] Reloading scores (Watch Only mode) for team:", teamName);

    const scoreInputs = document.querySelectorAll("#table input, #table textarea, #table select");
    scoreInputs.forEach(inp => inp.disabled = false);

    // Clear values + reset shading
    scoreInputs.forEach(inp => {
      inp.value = "";
      inp.style.backgroundColor = ""; // reset inline background
      inp.className = inp.className.replace(/\b(score-(good|bad|neutral))\b/g, ""); // remove custom score classes
    });

    google.script.run
      .withSuccessHandler(function(data) {
        console.log("üìä [DEBUG] Backend scores received:", data);
        populateScorecardWithSavedResults(data);
        disableInputs();
      })
      .withFailureHandler(function(error) {
        console.error("‚ùå [DEBUG] Failed to fetch backend scores:", error);
      })
      .loadScoresForTeam(teamName);
  }

  reloadScores();

  if (window.reloadInterval) clearInterval(window.reloadInterval);
  window.reloadInterval = setInterval(reloadScores, 30000);
}





  function getScoreLabelClass(scoreLabel) {
    console.log("Checking score label:", scoreLabel);
    if (scoreLabel.includes("Birdie")) {
      console.log(" -> Found Birdie");
      return "label-birdie";
    }
    if (scoreLabel.includes("Eagle")) {
      console.log(" -> Found Eagle");
      return "label-eagle";
    }
    if (scoreLabel.includes("Albatross")) {
      console.log(" -> Found Albatross");
      return "label-albatross";
    }
    if (scoreLabel.includes("Par")) {
      console.log(" -> Found Par");
      return "label-par";
    }
    console.log(" -> Defaulting to Par");
    return "label-par";
  }



  function loadABScoreboard() {
    google.script.run.withSuccessHandler(populateABTable).getScoreABSummaryFromSheet();
  }
  function populateABTable(results) {
    const tbody = document.getElementById("scoreboardAB-body");
    tbody.innerHTML = "";
    if (!results.length) {
      tbody.innerHTML = "<tr><td colspan='2'>No Skins Yet</td></tr>";
      console.log("AB Table: No Skins Yet");
      return;
    }
    results.forEach(([score, player]) => {
      console.log(`AB Table Row: score='${score}', player='${player}'`);
      const labelClass = getScoreLabelClass(score);
      console.log(` -> Applying class '${labelClass}'`);
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="${labelClass}">${score}</td>
        <td>${player}</td>
      `;
      tbody.appendChild(tr);
    });
  }


  function loadCDScoreboard() {
    google.script.run.withSuccessHandler(populateCDTable).getScoreCDSummaryFromSheet();
  }
  function populateCDTable(results) {
    const tbody = document.getElementById("scoreboardCD-body");
    tbody.innerHTML = "";
    if (!results.length) {
      tbody.innerHTML = "<tr><td colspan='2'>No Skins Yet</td></tr>";
      console.log("CD Table: No results found");
      return;
    }
    results.forEach(([score, player]) => {
      console.log(`CD Table Row: score='${score}', player='${player}'`);
      const labelClass = getScoreLabelClass(score);
      console.log(` -> Applying class '${labelClass}'`);
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td class="${labelClass}">${score}</td>
        <td>${player}</td>
      `;
      tbody.appendChild(tr);
    });
  }


   function loadTeamScoreboard() {
    google.script.run.withSuccessHandler(populateTeamTable).getScoreTeamSummaryFromSheet();
  }
  function populateTeamTable(results) {
  const tbody = document.getElementById("scoreboardTeam-body");
  tbody.innerHTML = "";
  if (!results.length) {
    tbody.innerHTML = "<tr><td colspan='4'>Awaiting Scores</td></tr>";
    return;
  }

  // Extract arrays of each score column for max calculation
  const frontNets = results.map(row => Number(row[1]) || 0);
  const backNets = results.map(row => Number(row[2]) || 0);
  const totalNets = results.map(row => Number(row[3]) || 0);

  const maxFront = Math.max(...frontNets);
  const maxBack = Math.max(...backNets);
  const maxTotal = Math.max(...totalNets);

  results.forEach(([team, frontNet, backNet, totalNet]) => {
    const tr = document.createElement("tr");

    // Prepare td with conditional highlight class
    const frontClass = (frontNet === maxFront) ? "highlight-max" : "";
    const backClass = (backNet === maxBack) ? "highlight-max" : "";
    const totalClass = (totalNet === maxTotal) ? "highlight-max" : "";

    tr.innerHTML = `
      <td>${team}</td>
      <td class="${frontClass}">${frontNet}</td>
      <td class="${backClass}">${backNet}</td>
      <td class="${totalClass}">${totalNet}</td>
    `;
    tbody.appendChild(tr);
  });
}



    // Call all three functions for the Scoreboard
  function refreshScoreboards() {
    const button = document.getElementById("refresh-btn");
    button.disabled = true;
    button.textContent = "Loading‚Ä¶";

    Promise.all([
      new Promise(resolve => google.script.run.withSuccessHandler(() => resolve()).getScoreABSummaryFromSheet()),
      new Promise(resolve => google.script.run.withSuccessHandler(() => resolve()).getScoreCDSummaryFromSheet()),
      new Promise(resolve => google.script.run.withSuccessHandler(() => resolve()).getScoreTeamSummaryFromSheet()) 
    ]).finally(() => {
      button.disabled = false;
      button.textContent = "Refresh Scoreboards";
    });

    loadABScoreboard();
    loadCDScoreboard();
    loadTeamScoreboard();
  }

  // Attach event
  document.getElementById("refresh-btn").addEventListener("click", refreshScoreboards);

  // Load initially
  window.onload = refreshScoreboards;




  document.addEventListener("DOMContentLoaded", function() {
    const teeTimeInput = document.getElementById('team');

    // Listen for changes in the tee time input field
    teeTimeInput.addEventListener('input', function() {
      if (teeTimeInput.value) {
        // Scale down the page to 1.4x after selecting a tee time
        document.documentElement.style.zoom = '1.4';
        }
    });
    });




function createCheckboxRow(teamConfig) {
    const containerDiv = document.createElement("div");
    containerDiv.style.display = "flex";
    containerDiv.style.alignItems = "center";

    // Add spacing row
    const nullRowAbove = document.createElement("div");
    nullRowAbove.style.height = "20px"; 
    containerDiv.appendChild(nullRowAbove);

    // === Only create Delete Player header and checkboxes if NOT in Watch Only mode ===
    if (!window.watchOnlyActive) {
        // Add header for delete player
        const headerDiv = document.createElement("div");
        headerDiv.innerHTML = "<b style='font-size: 1.4em; color: red;'>Delete Player</b>"; 
        headerDiv.style.marginRight = "20px"; 
        containerDiv.appendChild(headerDiv);

        // Create a single row of checkboxes
        const boxDiv = document.createElement("div");

        for (let j = 0; j < teamConfig.players.length; j++) {
            const checkboxContainer = document.createElement("label");
            checkboxContainer.style.display = "inline-block";
            checkboxContainer.style.marginLeft = "50px";
            checkboxContainer.style.width = "30px";
            checkboxContainer.style.height = "30px";
            checkboxContainer.style.backgroundColor = "red";
            checkboxContainer.style.borderRadius = "4px";
            checkboxContainer.style.cursor = "pointer";
            checkboxContainer.style.textAlign = "center";
            checkboxContainer.style.lineHeight = "30px";

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.style.opacity = "0"; 
            checkbox.style.width = "30px"; 
            checkbox.style.height = "30px"; 
            checkbox.style.margin = "0"; 

            // Handle checkbox actions with pop-up confirmation
            checkbox.onchange = function () {
                if (checkbox.checked) {
                    const playerName = document.getElementById(idPlayerName(j)).value;
                    const confirmation = confirm(
                        `Do you really want to delete ${playerName}, his Target Pts, and Scores?\n\n` +
                        `If sure, hit OK, if not, hit Cancel.\n\n` +
                        `Note: After the deletion, you have about 5 secs average to hit the Reload button to retrieve the deleted info. But after that, it is gone.`
                    );

                    if (!confirmation) {
                        checkbox.checked = false; // Ensure checkbox remains unchecked if canceled
                        return;
                    }

                    checkboxContainer.style.color = "white"; 
                    checkboxContainer.innerHTML = "‚úî"; 
                    deletePlayerAndTarget(j, checkbox); 
                    updateTeamTarget(teamConfig.players.length); 
                } else {
                    checkboxContainer.style.color = ""; 
                    checkboxContainer.innerHTML = ""; 
                }
            };

            checkboxContainer.appendChild(checkbox); 
            boxDiv.appendChild(checkboxContainer); 
        }

        containerDiv.appendChild(boxDiv);
    }

    // Add final spacing row
    const nullRowBelow = document.createElement("div");
    nullRowBelow.style.height = "200px"; 
    containerDiv.appendChild(nullRowBelow);

    return containerDiv;
}





  const RESULTS = [{
        name: "Total 18",
        startInclusive: 0,
        endExclusive: 18,
    }, {
        name: "Front 9",
        startInclusive: 0,
        endExclusive: 9
    }, {
        name: "Back 9",
        startInclusive: 9,
        endExclusive: 18
    }];

  const TEST_CONFIG = {
      "courseConfig": {
          "date": "2000-01-01",
          "courseName": "Test Course",
          "pars": [4, 4, 5, 3, 4, 5, 4, 3, 4, 4, 4, 5, 3, 4, 4, 3, 4, 5]
      },
      "allTeamConfigs": [
          {
              "teamName": "9:20",
              "players": [
                  { "playerName": "AAAA AAAAAAA", "playerTarget": 24 },
                  { "playerName": "BBBBB BBBBBB", "playerTarget": 21 },
                  { "playerName": "CCC CCCCCC", "playerTarget": 15 }
              ]
          },
          {
              "teamName": "9:30",
              "players": [
                  { "playerName": "DDDDD DDDD", "playerTarget": 29 },
                  { "playerName": "EEEE EEEEEEEEE", "playerTarget": 25 },
                  { "playerName": "FFFFF FFFFFF", "playerTarget": 21 },
                  { "playerName": "GGG GGGGG", "playerTarget": 15 }
                  // { "playerName": "HHHHHHHHH", "playerTarget": 21 },
                  // { "playerName": "IIIIIIIII", "playerTarget": 15 }
              ]
          }
      ]
  }


  function spreadsheetConfig() {
      // This function exists to making testing iteration more straightforward.
      // AppScript will inject the variable CONFIG *before* the HTML content.
      if (typeof CONFIG === "undefined") {
          console.log("Falling back to TEST_CONFIG.");
          return TEST_CONFIG;
      }
      console.log("Loaded config:\n" + JSON.stringify(CONFIG));
      return CONFIG;
  }

  createScorecard(RESULTS, spreadsheetConfig());



  function createScorecard(RESULTS, spreadsheetConfig) {
      document.getElementById("course").textContent = spreadsheetConfig.courseConfig.courseName;
      document.getElementById("date").textContent = spreadsheetConfig.courseConfig.date;

      document.getElementById("team").onchange = function (event) {
          teamOnchange(RESULTS, spreadsheetConfig);
      };

      createTeamOptions(spreadsheetConfig.allTeamConfigs); // This already populates the select box
  }


  let scoreKeeper;
  let teamName;


/**
function getScorer(teamConfig) {
  console.log("getScorer called with teamConfig:", teamConfig);

  if (!teamConfig || !teamConfig.players || teamConfig.players.length === 0) {
    alert("No players found in this team.");
    return;
  }

  const popup = document.createElement('div');
  popup.style.position = 'fixed';
  popup.style.top = '50%';
  popup.style.left = '50%';
  popup.style.transform = 'translate(-50%, -50%)';
  popup.style.background = 'white';
  popup.style.border = '2px solid #ccc';
  popup.style.borderRadius = '10px';
  popup.style.padding = '20px';
  popup.style.zIndex = '1000';
  popup.style.textAlign = 'center';
  popup.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';

  popup.innerHTML = `
    <div style="color: red; font-weight: bold; font-size: 1.2em;">
      ONLY ONE OF THESE PLAYERS (AT A TIME) MAY KEEP SCORE FOR THIS TEAM
    </div>
    <div style="height: 1em;"></div>
    <div style="color: orange; font-weight: bold; font-size: 1.2em;">
      But many can "Watch Only This Team".
    </div>
    <div style="height: 1em;"></div>
    <div style="color: blue; font-size: 1.2em; margin-bottom: 10px;">
      WHICH IS THE SCOREKEEPER?
    </div>
  `;

  const playerNames = teamConfig.players.map(p => p.playerName);

  playerNames.forEach(name => {
    const button = document.createElement('button');
    button.textContent = name;
    button.style.display = 'block';
    button.style.width = '100%';
    button.style.margin = '20px 0';
    button.style.padding = '10px';
    button.style.fontSize = '1em';
    button.onclick = () => {
      scoreKeeper = name;
      teamName = teamConfig.teamName;
      console.log("Scorekeeper selected:", name);
      document.body.removeChild(popup);
      google.script.run.recordScorerActivity({
        teamName: teamConfig.teamName,
        playerName: name,
        activity: "Scorekeeper"
      });
    };
    popup.appendChild(button);
  });

  // Spacer
  const spacer = document.createElement('div');
  spacer.style.height = '20px';
  popup.appendChild(spacer);

  // === WATCH ONLY BUTTON ===
  const watchOnlyBtn = document.createElement('button');
  watchOnlyBtn.textContent = 'Watch Only This Team';
  watchOnlyBtn.style.display = 'block';
  watchOnlyBtn.style.width = '100%';
  watchOnlyBtn.style.margin = '10px 0';
  watchOnlyBtn.style.padding = '10px';
  watchOnlyBtn.style.fontSize = '1em';
  watchOnlyBtn.style.backgroundColor = 'orange';
  watchOnlyBtn.style.color = 'white';
  watchOnlyBtn.style.border = 'none';
  watchOnlyBtn.style.cursor = 'pointer';

  watchOnlyBtn.onclick = () => {
    watchOnlyMode();
    document.body.removeChild(popup);
  };

  popup.appendChild(watchOnlyBtn);

  document.body.appendChild(popup);
}
*/


  function getScorer(teamConfig) {
    console.log("getScorer called with teamConfig:", teamConfig);

    if (!teamConfig || !teamConfig.players || teamConfig.players.length === 0) {
      alert("No players found in this team.");
      return;
    }

    const popup = document.createElement('div');
    popup.style.position = 'fixed';
    popup.style.top = '50%';
    popup.style.left = '50%';
    popup.style.transform = 'translate(-50%, -50%)';
    popup.style.background = 'white';
    popup.style.border = '2px solid #ccc';
    popup.style.borderRadius = '10px';
    popup.style.padding = '20px';
    popup.style.zIndex = '1000';
    popup.style.textAlign = 'center';
    popup.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';

    popup.innerHTML = `
      <div style="color: red; font-weight: bold; font-size: 1.2em;">
        ONLY ONE OF THESE PLAYERS (AT A TIME) MAY KEEP SCORE FOR THIS TEAM
      </div>
      <div style="height: 1em;"></div>
      <div style="color: orange; font-weight: bold; font-size: 1.2em;">
        But many can "Watch Only This Team".
      </div>
      <div style="height: 1em;"></div>
      <div style="color: blue; font-size: 1.2em; margin-bottom: 10px;">
        WHICH IS THE SCOREKEEPER?
      </div>
    `;

    const playerNames = teamConfig.players.map(p => p.playerName);

    playerNames.forEach(name => {
      const button = document.createElement('button');
      button.textContent = name;
      button.style.display = 'block';
      button.style.width = '100%';
      button.style.margin = '20px 0';
      button.style.padding = '10px';
      button.style.fontSize = '1em';
      button.onclick = () => {
        scoreKeeper = name;
        teamName = teamConfig.teamName;
        console.log("Scorekeeper selected:", name);
        document.body.removeChild(popup);

        // Record scorer in backend
        google.script.run.recordScorerActivity({
          teamName: teamConfig.teamName,
          playerName: name,
          activity: "Scorekeeper"
        });

        // ‚úÖ Remove Scoreboard Only button if it exists
        const scoreboardBtn = document.getElementById("scoreboard_button");
        if (scoreboardBtn) {
          scoreboardBtn.remove();
        }

      };
      popup.appendChild(button);
    });

    // Spacer
    const spacer = document.createElement('div');
    spacer.style.height = '20px';
    popup.appendChild(spacer);

    // === WATCH ONLY BUTTON ===
    const watchOnlyBtn = document.createElement('button');
    watchOnlyBtn.textContent = 'Watch Only This Team';
    watchOnlyBtn.style.display = 'block';
    watchOnlyBtn.style.width = '100%';
    watchOnlyBtn.style.margin = '10px 0';
    watchOnlyBtn.style.padding = '10px';
    watchOnlyBtn.style.fontSize = '1em';
    watchOnlyBtn.style.backgroundColor = 'orange';
    watchOnlyBtn.style.color = 'white';
    watchOnlyBtn.style.border = 'none';
    watchOnlyBtn.style.cursor = 'pointer';

    watchOnlyBtn.onclick = () => {
      watchOnlyMode();
      document.body.removeChild(popup);

      // ‚úÖ Remove Scoreboard Only button if it exists
      const scoreboardBtn = document.getElementById("scoreboard_button");
      if (scoreboardBtn) {
        scoreboardBtn.remove();
      }
    };

    popup.appendChild(watchOnlyBtn);

    document.body.appendChild(popup);
  }




  function createTeamOptions(allTeamConfigs) {
    const teamSelect = document.getElementById("team");  // Assuming 'team' is the id of your <select> element

    // Clear existing options except the placeholder
    teamSelect.innerHTML = '<option value="" disabled selected>Select</option>';

    // Populate the <select> options with team names
    for (let teamIndex = 0; teamIndex < allTeamConfigs.length; teamIndex++) {
        const teamOption = document.createElement("option");
        teamOption.value = allTeamConfigs[teamIndex].teamName;
        teamOption.text = allTeamConfigs[teamIndex].teamName;  // Set display text for option
        teamSelect.appendChild(teamOption);
    }

    // Add an event listener to disable the select once a team is selected
    teamSelect.addEventListener('change', function() {
        if (teamSelect.value) {  // Ensure a valid selection (not the placeholder)
            teamSelect.disabled = true;  // Disable the select after selection
            console.log(`Selected team: ${teamSelect.value}`);
        }
    });
  }


 function clearLocalStorageButPreserveTeamsAutosave(teams) {
    // Build the keys to keep based on teams array
    const keysToKeep = teams.map(team => "autosaveDisabledDate_" + team.teamName);

    // Backup the values of those keys
    const backup = {};
    keysToKeep.forEach(key => {
      const val = localStorage.getItem(key);
      if (val !== null) {
        backup[key] = val;
      }
    });

    // Clear everything
    localStorage.clear();

    // Restore preserved keys
    Object.entries(backup).forEach(([key, val]) => {
      localStorage.setItem(key, val);
    });

    console.log("Preserved keys after clear:", Object.keys(backup));
  }



  // initial score reload to try 5 times before auto save starts
function initScoreReloadAndAutoSaveSafety() {
  // Tracks whether reload has succeeded at least once
  window.initialReloadSucceeded = false;

  // Utility: check if scorecard is empty
  function isScorecardEmpty() {
    return [...document.querySelectorAll("#table input, #table textarea")]
      .every(inp => inp.value.trim() === "");
  }

  // Wrapper to reload scores with custom handlers
  function reloadScoresWithHandlers(onSuccess, onFailure) {
    const teamName = document.getElementById("team")?.value;
    if (!teamName) {
      console.warn("‚ö†Ô∏è No team selected for reload.");
      return;
    }

    console.log("üîÑ Reloading scores for team:", teamName);

    google.script.run
      .withSuccessHandler((data) => {
        console.log("‚úÖ Backend scores received:", data);
        populateScorecardWithSavedResults(data);
        disableInputs();
        if (typeof onSuccess === "function") onSuccess();
      })
      .withFailureHandler((err) => {
        console.error("‚ùå Reload failed:", err);
        if (typeof onFailure === "function") onFailure(err);
      })
      .loadScoresForTeam(teamName);
  }

  // Attempt initial reload up to 5 times with backoff
  function attemptInitialReload(attempt = 1) {
    console.log(`üîÅ Initial reload attempt ${attempt}`);
    reloadScoresWithHandlers(
      () => {
        window.initialReloadSucceeded = true;
        console.log("‚úÖ Initial reload succeeded");
      },
      (error) => {
        if (attempt < 5) {
          const delay = attempt * 2000; // exponential backoff
          console.warn(`‚è≥ Retry reload in ${delay / 1000}s (attempt ${attempt + 1})`);
          setTimeout(() => attemptInitialReload(attempt + 1), delay);
        } else {
          console.error("‚ùå All reload attempts failed. Auto-save paused.");
          alert("Could not load saved scores. Auto-save paused.");
        }
      }
    );
  }

  // Hook into existing auto-save by wrapping save checks
  const origClick = HTMLElement.prototype.click;
  HTMLElement.prototype.click = function () {
    if (this.id === "submit_button" || this.id?.includes("save")) {
      if (!window.initialReloadSucceeded) {
        console.warn("‚è∏Ô∏è Auto-save skipped ‚Äî reload not yet successful");
        return;
      }
      if (isScorecardEmpty()) {
        console.warn("‚ö†Ô∏è Auto-save skipped ‚Äî scorecard appears empty");
        return;
      }
    }
    return origClick.apply(this, arguments);
  };

  // Start the first reload attempts
  attemptInitialReload();
}



function teamOnchange(RESULTS, spreadsheetConfig) {
  console.log("teamOnchange start");

  // Block normal changes if Scoreboard Only active
  if (scoreboardOnlyActive && !watchOnlyActive) {
    console.log("teamOnchange blocked due to Scoreboard Only mode.");
    return;
  }

  const tableDiv = document.getElementById("table");
  tableDiv.innerHTML = "";

  const selectedTeamConfig = getSelectedTeamConfig(spreadsheetConfig.allTeamConfigs);

  // Insert checkbox row at the top
  const checkboxRow = createCheckboxRow(selectedTeamConfig);
  tableDiv.appendChild(checkboxRow);

  // Create Save/Load buttons
  createSaveLoadButtons(spreadsheetConfig, selectedTeamConfig);

  const breakDiv = document.createElement("div");
  breakDiv.style.height = "20px";
  tableDiv.appendChild(breakDiv);

  // Create the scorecard table
  createScorecardTable(RESULTS, spreadsheetConfig.courseConfig, selectedTeamConfig);

  // Bottom save button
  createBottomSaveButton(spreadsheetConfig, selectedTeamConfig);

  // Enable buttons only if NOT in Watch Only mode
  if (!window.watchOnlyActive) {
    const submitBtn = document.getElementById("submit_button");
    if (submitBtn) submitBtn.disabled = false;

    const clearBtn = document.getElementById("clear_button");
    if (clearBtn) clearBtn.disabled = false;
  }

  // ‚ö†Ô∏è Removed direct google.script.run.loadScoresForTeam here
  // Reload + retries + autosave safety will be handled instead

  // Play sound once
  if (!hasPlayed) {
    const audio = document.getElementById("audio");
    audio.play().catch(err => console.error("Audio failed:", err));
    hasPlayed = true;
  }

  getScorer(selectedTeamConfig);

  // Safer reload with retries + autosave gating
  initScoreReloadAndAutoSaveSafety();
}




      // only for testing
    function resetAutoSaveFlagForCurrentTeam() {
      const teamName = document.getElementById("team")?.value || "UNKNOWN_TEAM";
      const teamKey = `autosaveDisabledDate_${teamName}`;
      localStorage.removeItem(teamKey);
      console.log(`üö© Auto-save flag reset for team "${teamName}". Current flag value:`, localStorage.getItem(teamKey));
    }



function createSaveLoadButtons(spreadsheetConfig, selectedTeamConfig) {
  try {
    console.log("‚û° createSaveLoadButtons called.");

    const container = document.getElementById("table");
    if (!container) {
      console.error("‚ùå Table element with id 'table' not found.");
      return;
    }

    // Remove previous button sets
    const existingSubs = container.querySelectorAll(".save-load-buttons, .save-button-bottom");
    existingSubs.forEach(el => el.remove());

    // ==== TOP SAVE/LOAD BUTTONS ====
    const topSubTable = document.createElement("table");
    topSubTable.classList.add("save-load-buttons");
    const topTr = document.createElement("tr");

    const saveElement = document.createElement("td");
    const topSaveContainer = createSaveButton(spreadsheetConfig, selectedTeamConfig, "top");
    const topSaveButton = topSaveContainer.querySelector("button");
    saveElement.appendChild(topSaveContainer);
    saveElement.style.paddingRight = "25px";
    saveElement.style.paddingBottom = "10px";
    saveElement.style.paddingTop = "10px";

    const loadElement = document.createElement("td");
    const loadButton = createLoadButton();
    loadElement.appendChild(loadButton);
    loadElement.style.paddingLeft = "20px";
    loadElement.style.paddingBottom = "10px";
    loadElement.style.paddingTop = "10px";

    const statusElement = document.createElement("td");
    const autoSaveStatus = document.createElement("span");
    autoSaveStatus.id = "autosave_status_top";
    autoSaveStatus.style.fontSize = "20px";
    statusElement.appendChild(autoSaveStatus);

    topTr.appendChild(saveElement);
    topTr.appendChild(loadElement);
    topTr.appendChild(statusElement);
    topSubTable.appendChild(topTr);
    container.prepend(topSubTable);

    // === AUTOSAVE SETUP (Top button only) ===
    const teamName = selectedTeamConfig?.team || document.getElementById("team")?.value || "UNKNOWN_TEAM";
    const teamKey = `autosaveDisabledDate_${teamName}`;
    const storedDate = localStorage.getItem(teamKey);
    const today = new Date().toISOString().slice(0, 10);
    window.autoSaveManuallyDisabled = (storedDate === today);

    // Only set status if NOT watchOnly
    if (!window.watchOnlyActive) {
      if (window.autoSaveManuallyDisabled) {
        autoSaveStatus.innerHTML = "<b>Auto-save disabled for today (scores already submitted)</b>";
        autoSaveStatus.style.color = "red";
      } else {
        autoSaveStatus.innerHTML = "<b>Auto-save is active</b>";
        autoSaveStatus.style.color = "green";
      }
    }

    // === VISIBILITY HANDLING ===
    if (typeof window.isTabActive === "undefined") {
      window.isTabActive = !document.hidden;
      window.autoSavePaused = !window.isTabActive;
      window.resumePending = false;
      window.justResumed = false;

      document.addEventListener("visibilitychange", () => {
        const statusEl = document.getElementById("autosave_status_top");
        window.isTabActive = !document.hidden;

        if (!window.watchOnlyActive) { // Skip updates in watchOnly mode
          if (document.hidden) {
            window.autoSavePaused = true;
            window.resumePending = false;
            window.justResumed = false;
            if (statusEl && !window.autoSaveManuallyDisabled) {
              statusEl.innerHTML = "<b>Auto-save paused (tab not visible)</b>";
              statusEl.style.color = "red";
            }
          } else {
            window.autoSavePaused = false;
            window.resumePending = true;
            window.justResumed = true;
          }
        }
      });
    }

    // === AUTOSAVE INTERVAL ===
    if (topSaveButton && typeof initialDelaySec !== "undefined" && typeof saveIntervalSec !== "undefined") {
      setTimeout(() => {
        window.saveInterval = setInterval(() => {
          const statusEl = document.getElementById("autosave_status_top");

          // Skip autosave entirely in watchOnly
          if (window.watchOnlyActive || window.autoSaveManuallyDisabled || inputsLocked || window.autoSavePaused) {
            console.log("‚è∏Ô∏è Skipping auto-save");
            return;
          }

          if (window.resumePending) {
            console.log("‚è≥ Skipping one interval after resume");
            window.resumePending = false;
            return;
          }

          if (window.justResumed) {
            window.justResumed = false;
            if (statusEl && !window.autoSaveManuallyDisabled) {
              statusEl.innerHTML = "<b>Auto-save is active</b>";
              statusEl.style.color = "green";
            }
          }

          console.log("üíæ Auto-save triggered");
          topSaveButton.click();
        }, saveIntervalSec * 1000);
      }, initialDelaySec * 1000);
    } else {
      console.error("‚ùå Could not start auto-save ‚Äî missing button or delay values");
    }

  } catch (e) {
    console.error("‚ùå Exception in createSaveLoadButtons:", e);
  }
}




function createBottomSaveButton(spreadsheetConfig, selectedTeamConfig) {
  const container = document.getElementById("table");
  if (!container) return;

  const bottomSaveContainer = createSaveButton(spreadsheetConfig, selectedTeamConfig, "bottom");
  bottomSaveContainer.classList.add("save-button-bottom");
  bottomSaveContainer.style.marginTop = "25px";

  // Find the last result row and insert after it
  const allResultRows = container.querySelectorAll("tr[id^='resultRow_']");
  const lastResultRow = allResultRows[allResultRows.length - 1];

  if (lastResultRow && lastResultRow.parentNode) {
    const newRow = document.createElement("tr");
    const td = document.createElement("td");
    td.colSpan = 3;
    td.appendChild(bottomSaveContainer);
    newRow.appendChild(td);
    lastResultRow.parentNode.insertBefore(newRow, lastResultRow.nextSibling);
  } else {
    container.appendChild(bottomSaveContainer); // fallback
  }
}


function createSaveButton(spreadsheetConfig, selectedTeamConfig, positionSuffix) {
  const container = document.createElement("div");

  const button = document.createElement("button");
  button.innerHTML = "Save";
  button.style.fontSize = "30px";
  button.style.color = "green";
  button.style.padding = "10px 10px";
  button.id = `save_button_${positionSuffix}`;

  const statusSpan = document.createElement("span");
  statusSpan.style.fontSize = "20px";
  statusSpan.style.color = "green";
  statusSpan.style.marginLeft = "10px";
  statusSpan.id = `save_status_${positionSuffix}`;

  let isSaving = false;

  button.onclick = function () {
    if (isSaving || inputsLocked) {
      console.log("Save is temporarily disabled or already in progress.");
      return;
    }

    isSaving = true;

    const originalText = button.textContent;
    button.textContent = "Saving...";
    button.classList.add("loading");

    const out = [];
    for (let currPlayerIndex = 0; currPlayerIndex < selectedTeamConfig.players.length; currPlayerIndex++) {
      const currPlayerScores = [];

      // Push player name and target
      currPlayerScores.push(document.getElementById(idPlayerName(currPlayerIndex))?.value || "");
      currPlayerScores.push(document.getElementById(idTarget(currPlayerIndex))?.value || "");

      // Push hole scores
      for (let holeIndex = 0; holeIndex < spreadsheetConfig.courseConfig.pars.length; holeIndex++) {
        const val = document.getElementById(idHolePlayer(holeIndex, currPlayerIndex))?.value || "";
        currPlayerScores.push(val);
      }

      out.push(currPlayerScores);
    }

    console.log(`üíæ Saving from [${positionSuffix}] button. Payload:`, out);

    google.script.run
      .withSuccessHandler(function () {
        isSaving = false;
        button.textContent = originalText;
        button.classList.remove("loading");

        const now = new Date();
        const time = `${now.getHours()}:${now.getMinutes().toString().padStart(2, "0")}`;
        statusSpan.innerHTML = `<b><i>Saved at</i></b> ${time}`;
        statusSpan.style.color = "green";
      })
      .withFailureHandler(function (error) {
        isSaving = false;
        button.textContent = originalText;
        button.classList.remove("loading");

        statusSpan.textContent = "Failed to Save";
        statusSpan.style.color = "red";
        console.error("‚ùå Error saving scores:", error);
      })
      .saveScoresForTeam(document.getElementById("team").value, out);
  };

  container.appendChild(button);
  container.appendChild(statusSpan);
  return container;
}









  function createLoadButton() {
    const container = document.createElement("div");

    const button = document.createElement("button");
    button.id = "reload_button";
    button.innerHTML = "Re-Load";
    button.style.fontSize = "30px";
    button.style.color = "blue";
    button.style.padding = "10px 10px";

    const statusSpan = document.createElement("span");
    statusSpan.id = "reload_status";
    statusSpan.style.fontSize = "20px";
    statusSpan.style.color = "blue";
    statusSpan.style.marginLeft = "10px";

    button.onclick = function () {
      if (button.classList.contains("loading")) return;

      button.classList.add("loading");

      const teamName = document.getElementById("team").value;
      google.script.run
        .withSuccessHandler(function (results) {
          populateScorecardWithSavedResults(results);
          const now = new Date();
          const time = `${now.getHours()}:${now.getMinutes().toString().padStart(2, "0")}`;
          statusSpan.innerHTML = `<b><i>Re-Loaded at</i></b> ${time}`;
          statusSpan.style.color = "blue";
          button.classList.remove("loading");
        })
        .withFailureHandler(function (error) {
          statusSpan.textContent = "Failed to Re-Load";
          statusSpan.style.color = "red";
          console.error("Error loading scores:", error);
          button.classList.remove("loading");
        })
        .loadScoresForTeam(teamName);
    };

    container.appendChild(button);
    container.appendChild(statusSpan);

    return container;
  }




  function populateScorecardWithSavedResults(allPlayerScores) {
    const paramSpreadsheetConfig = spreadsheetConfig();

    console.log("Loading saved scores: " + JSON.stringify(allPlayerScores));

    const selectedTeamConfig = getSelectedTeamConfig(paramSpreadsheetConfig.allTeamConfigs);

    for (let currPlayerIndex = 0; currPlayerIndex < selectedTeamConfig.players.length; currPlayerIndex++) {
        if (currPlayerIndex >= allPlayerScores.length) {
            break;
        }
        let currPlayerScores = allPlayerScores[currPlayerIndex];

        console.log(`Processing player ${currPlayerIndex}: ${JSON.stringify(currPlayerScores)}`);

        // Set player name
        if (currPlayerScores.length >= 1) {
            const playerNameInput = document.getElementById(idPlayerName(currPlayerIndex));
            if (playerNameInput) {
                playerNameInput.value = currPlayerScores[0];
                console.log(`Set player name: ${currPlayerScores[0]}`);
            } else {
                console.log(`Player name input not found for player index ${currPlayerIndex}`);
            }
        }

        // Set target
        if (currPlayerScores.length >= 2 && typeof currPlayerScores[1] === "number") {
            const targetInput = document.getElementById(idTarget(currPlayerIndex));
            if (targetInput) {
                targetInput.value = currPlayerScores[1];
                targetInput.oninput();
                console.log(`Set target: ${currPlayerScores[1]}`);
            } else {
                console.log(`Target input not found for player index ${currPlayerIndex}`);
            }
        }

        // Set hole scores
        for (let holeIndex = 0; holeIndex < paramSpreadsheetConfig.courseConfig.pars.length && holeIndex < (currPlayerScores.length - 2); holeIndex++) {
            let maybeScore = currPlayerScores[holeIndex + 2];
            const select = document.getElementById(idHolePlayer(holeIndex, currPlayerIndex));
            if (select) {
                if (typeof maybeScore === "number" && maybeScore > 0) {
                    select.value = maybeScore;
                } else {
                    select.value = "";
                }
                // Trigger the change event
                const event = new Event('change', { bubbles: true });
                select.dispatchEvent(event);
                console.log(`Set score for hole ${holeIndex}: ${select.value}`);
            } else {
                console.log(`Score select not found for hole ${holeIndex} and player index ${currPlayerIndex}`);
            }
        }
    }
  }


  function getSelectedTeamConfig(allTeamConfigs) {
    const teamName = document.getElementById("team").value;

    let selectedTeamConfig = {
    "teamName": "",
    "players": [
    { "playerName": "", "playerTarget": null },
    { "playerName": "", "playerTarget": null },
    { "playerName": "", "playerTarget": null },
    { "playerName": "", "playerTarget": null },
    ]
    };

    for (let teamConfig of allTeamConfigs) {
    if (teamName === teamConfig.teamName) {
    selectedTeamConfig = teamConfig;
    }
    }

    return selectedTeamConfig;
  }


    // Function that gets called after the page expands
  function createScorecardTable(RESULTS, courseConfig, teamConfig) {
    document.getElementById("table").appendChild(
    generateTable(RESULTS, courseConfig, teamConfig));

    for (const result of RESULTS) {
      const refRow = document.getElementById(idHoleRow(result.endExclusive - 1));
      const refTable = refRow.parentElement;

      const newRows = generateResultTable(result, teamConfig.players.length);

      // Loop over these rows in reverse, so they appear in order.
      for (let rowIndex = newRows.length - 1; rowIndex >= 0; rowIndex--) {
          const placeholderRow = refTable.insertRow(refRow.rowIndex + 1);
          refTable.replaceChild(newRows[rowIndex], placeholderRow);
      }
    }

      // We could have loaded some cached scores.
    updateAllStats(RESULTS, courseConfig.pars, teamConfig.players.length);

  }


  function generateTable(results, courseConfig, teamConfig) {
      const table = document.createElement("table");

      const numHoles = courseConfig.pars.length;

      const nameRow = generateNameRow(teamConfig);
      table.appendChild(nameRow);

      const targetRow = generateTargetRow(results, courseConfig.pars, teamConfig);
      table.appendChild(targetRow);

      for (let holeIndex = 0; holeIndex < numHoles; holeIndex++) {
          const row = generateHoleRow(results, courseConfig.pars, holeIndex, teamConfig.players.length);
          table.appendChild(row);
      }

      return table;

  }



  function deletePlayerAndTarget(playerIndex, checkbox) {
    saveBeforeDelete();

    document.getElementById(idPlayerName(playerIndex)).value = "x";
    document.getElementById(idTarget(playerIndex)).value = "0";

    // Clear scores for the selected deleted player
    clearScoresAndCacheForPlayer(playerIndex);

    // Update localStorage
    localStorage.removeItem(idPlayerName(playerIndex));
    localStorage.removeItem(idTarget(playerIndex));

    for (let holeIndex = 0; holeIndex < 18; holeIndex++) {
      const scoreId = idHolePlayer(holeIndex, playerIndex);
      localStorage.removeItem(scoreId);
    }

    updateTeamTarget(getSelectedTeamConfig(spreadsheetConfig().allTeamConfigs).players.length);
    console.log("New Team Target After Player Deletion:", document.getElementById("team_target").textContent);
  }



 function saveBeforeDelete() {
      const localSpreadsheetConfig = spreadsheetConfig();
      const selectedTeamConfig = getSelectedTeamConfig(localSpreadsheetConfig.allTeamConfigs);
                  
      // --- Save Scores Before Submitting ---
      // Build an array of raw scores (similar to save button)
    let out = [];
    for (let currPlayerIndex = 0; currPlayerIndex < selectedTeamConfig.players.length; currPlayerIndex++) {
      let currPlayerScores = [];
      currPlayerScores.push(document.getElementById(idPlayerName(currPlayerIndex)).value);
      currPlayerScores.push(document.getElementById(idTarget(currPlayerIndex)).value);

      for (let holeIndex = 0; holeIndex < localSpreadsheetConfig.courseConfig.pars.length; holeIndex++) {
        currPlayerScores.push(document.getElementById(idHolePlayer(holeIndex, currPlayerIndex)).value);
      }

      out.push(currPlayerScores);
    }

    console.log("Saving before submitting: " + JSON.stringify(out));

    google.script.run
      .withSuccessHandler(function () {
        // Save to localStorage
        localStorage.setItem("savedScores", JSON.stringify(out));

        const now = new Date();
        const hours = now.getHours().toString();
        const minutes = now.getMinutes().toString().padStart(2, "0");
        const time = `${hours}:${minutes}`;
        document.getElementById("save_status").innerHTML =
          "<b><i>Saved at</i></b> " + time;
      })
      .withFailureHandler(function (error) {
        const statusElem = document.getElementById("save_status");
        statusElem.textContent = "Failed to Save";
        statusElem.style.cssText =
          "font-size: 40px; font-weight: bold; color: red;";
        console.error("Error saving scores:", error);
      })
      .saveScoresForTeam(document.getElementById("team").value, out);
  }



  function generateNameRow(teamConfig) {
    const row = document.createElement("tr");
    row.classList.add("sticky-header"); // Add sticky header class
    const headerCell = document.createElement("td");
    headerCell.textContent = "Name";
    headerCell.style.fontSize = "1.5em"; // Set the font size
    headerCell.style.fontWeight = "bold"; // Set the font weight
    row.appendChild(headerCell);
    for (let playerIndex = 0; playerIndex < teamConfig.players.length; playerIndex++) {
      const playerCell = document.createElement("td");
      const input = document.createElement("input");
      input.type = "text";
      input.id = idPlayerName(playerIndex);
      input.style.fontFamily = "'Arial Narrow', Arial, sans-serif";
      input.style.fontSize = "20px";
      input.style.padding = "5px 5px";
      input.style.width = "8ch";
      input.style.fontWeight = "bold";
      input.value = teamConfig.players[playerIndex].playerName;
      playerCell.appendChild(input);
      row.appendChild(playerCell);
    }
    return row;
  }


  function generateTargetRow(results, pars, teamConfig) {
      const row = document.createElement("tr");
      const headerCell = document.createElement("td");
      headerCell.textContent = "Target";
      headerCell.style.fontSize = "1.5em"; // Set the inline font size
      headerCell.style.fontWeight = "bold"; // Set the inline font weight to bold
      row.appendChild(headerCell);
      let teamTarget = 0;
      for (let playerIndex = 0; playerIndex < teamConfig.players.length; playerIndex++) {
          const currPlayerIndex = playerIndex;
          const playerCell = document.createElement("td");
          playerCell.align = "center";
          const input = document.createElement("input");
          input.type = "number";
          input.id = idTarget(playerIndex);
          input.style.width = "3ch";
          input.style.fontSize = "1.2em"; // Set the font size to 1.2em
          input.disabled = false;
          const playerTarget = teamConfig.players[playerIndex].playerTarget;
          input.value = playerTarget;
          const playerTargetOrZero = parseInt(playerTarget);
          if (!isNaN(playerTargetOrZero)) {
              teamTarget += playerTargetOrZero;
          }
          input.min = 0;
          input.oninput = function (event) {
              updateStats(results, pars, teamConfig.players.length, currPlayerIndex);
              updateTeamTarget(teamConfig.players.length);
          };
          playerCell.appendChild(input);
          row.appendChild(playerCell);
      }
      document.getElementById("team_target").textContent = teamTarget;
      return row;
  }


  function generateHoleRow(results, pars, holeIndex, numPlayers) {
      const row = document.createElement("tr");

      row.id = idHoleRow(holeIndex);

      const headerCell = generateHoleHeader(holeIndex, pars[holeIndex]);
      row.appendChild(headerCell);

      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const holeCell = generateHoleForPlayer(results, pars, holeIndex, numPlayers, playerIndex);
          row.appendChild(holeCell);
      }

        // Call the resize function after generating the row
    //resizePage();

      return row;
  }


  function generateHoleHeader(holeIndex, par) {
      const cell = document.createElement("td");
      cell.textContent = (holeIndex + 1) + " (" + par + ")";
      cell.style.fontSize = "1.5em"; // Set the inline font size to 1.5em

      return cell;
  }



  function generateHoleForPlayer(results, pars, holeIndex, numPlayers, playerIndex) {
    const cell = document.createElement("td");
    cell.style.textAlign = "center"; // Use style instead of align

    const select = document.createElement("select");
    const id = idHolePlayer(holeIndex, playerIndex);
    select.id = id;
    select.style.width = "5ch"; // Set width to 5ch
    select.style.fontSize = "1.2em"; // Increase font size to make text taller
    select.style.height = "2.5em"; // Increase height to make the box taller
    select.style.padding = "2px"; // Adjust padding if needed
    select.style.boxSizing = "border-box"; // Ensure padding is included in the height

    const possibleSavedScore = localStorage.getItem(id);
    const userScore = possibleSavedScore !== null ? possibleSavedScore : "";

    const minScore = getMinScore(pars[holeIndex]); // Calculate minScore using the function defined earlier
    const maxScore = getMaxScore(pars[holeIndex]); // Calculate maxScore using the function defined earlier

    // Add a null option
    const nullOption = document.createElement("option");
    nullOption.value = "";
    nullOption.text = ""; // Placeholder text if desired
    if (userScore === "") {
        nullOption.selected = true;
    }
    select.appendChild(nullOption);

    for (let score = minScore; score <= maxScore; score++) {
        const option = document.createElement("option");
        option.value = score;
        option.text = score;
        if (score == userScore) {
            option.selected = true;
        }
        select.appendChild(option);
    }

    // Apply initial background color based on userScore
    select.style.color = "black";
    select.style.backgroundColor = userScore === "" ? "yellow" : getHoleForPlayerColor(userScore, pars[holeIndex]);

    select.addEventListener('change', function(event) {
        const selectedScore = event.target.value;

        select.style.backgroundColor = selectedScore === "" ? "yellow" : getHoleForPlayerColor(selectedScore, pars[holeIndex]);
       
        localStorage.setItem(id, selectedScore);
        updateStats(results, pars, numPlayers, playerIndex);

        // Apply bold and larger font size to the selected option
        select.style.fontWeight = selectedScore ? "bold" : "normal";
        select.style.fontSize = "1.2em"; // Adjust font size as needed

        // Simulate the bold effect by adding a pseudo element for the selected option
        const options = select.querySelectorAll('option');
        options.forEach(option => {
            if (option.value === selectedScore) {
                option.style.fontWeight = "bold";
                option.style.fontSize = "1.2em";
            } else {
                option.style.fontWeight = "normal";
                option.style.fontSize = "1em"; // Default size
            }
        });
    });

    cell.appendChild(select);
    return cell;
  }


  function generateResultTable(partialResult, numPlayers) {
    const headerRow = document.createElement("tr");
    headerRow.textContent = partialResult.name;
    headerRow.style = "font-weight: bold; text-decoration: underline; font-size: 1.5em;";

    const scoreRow = generateResultScoreRow(partialResult.name, numPlayers);
    scoreRow.style.fontSize = "1.5em";

    const pointsRow = generateResultPointsRow(partialResult.name, numPlayers);
    pointsRow.style.fontSize = "1.5em";

    const netRow = generateResultNetRow(partialResult.name, numPlayers);
    netRow.style.fontSize = "1.5em";

    const pointsTeamRow = generateResultPointsTeamRow(partialResult.name);
    pointsTeamRow.style.fontSize = "1.5em";

    const netTeamRow = generateResultNetTeamRow(partialResult.name);
    netTeamRow.style.fontSize = "1.5em";

    return [headerRow, scoreRow, pointsRow, netRow, pointsTeamRow, netTeamRow];
  }


  function generateResultScoreRow(resultName, numPlayers) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Score";
      row.appendChild(headerCell);

      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const scoreCell = document.createElement("td");
          scoreCell.align = "center";
          scoreCell.id = idResultScorePlayer(resultName, playerIndex);
          scoreCell.textContent = 0;
          row.appendChild(scoreCell);
      }

      return row;
  }

  function generateResultPointsRow(resultName, numPlayers) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Points";
      row.appendChild(headerCell);

      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const pointsCell = document.createElement("td");
          pointsCell.align = "center";
          pointsCell.id = idResultPointsPlayer(resultName, playerIndex);
          pointsCell.textContent = 0;
          row.appendChild(pointsCell);
      }

      return row;
  }

  function generateResultNetRow(resultName, numPlayers) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Net";
      row.appendChild(headerCell);

      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const netCell = document.createElement("td");
          netCell.align = "center";
          netCell.id = idResultNetPlayer(resultName, playerIndex);
          netCell.textContent = "";
          row.appendChild(netCell);
      }

      return row;
  }

  function generateResultPointsTeamRow(resultName) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Team Points";
      headerCell.style = "font-weight: bold";
      row.appendChild(headerCell);

      const pointsCell = document.createElement("td");
      pointsCell.style = "font-weight: bold";
      pointsCell.align = "center";
      pointsCell.id = idResultPointsTeam(resultName);
      pointsCell.textContent = 0;
      row.appendChild(pointsCell);

      return row;
  }

  function generateResultNetTeamRow(resultName) {
      const row = document.createElement("tr");

      const headerCell = document.createElement("td");
      headerCell.textContent = "Team Net";
      headerCell.style = "font-weight: bold";
      row.appendChild(headerCell);

      const netCell = document.createElement("td");
      netCell.style = "font-weight: bold";
      netCell.align = "center";
      netCell.id = idResultNetTeam(resultName);
      netCell.textContent = "";
      row.appendChild(netCell);

      return row;
  }



  function applyPerformanceColor(cell, actual, expected, direction = "higher") {
    // ‚õîÔ∏è Prevent coloring for score cells
    if (cell.id && cell.id.toLowerCase().includes("score")) {
        console.warn("‚õîÔ∏è BLOCKED SCORE COLORING for:", cell.id);
        cell.style.color = ""; // Reset to default
        return;
    }

    // ü™µ Verbose logging to trace all cell updates
    console.log("applyPerformanceColor called with:", {
        cellId: cell.id,
        actual,
        expected,
        direction,
        cellText: cell.textContent
    });

    if (isNaN(actual) || isNaN(expected)) {
        cell.style.color = ""; // default black
        return;
    }

    if (actual === 0 && expected === 0) {
        cell.style.color = "";
        return;
    }

    if (actual === 0) {
        cell.style.color = "";
        return;
    }

    const ratio = direction === "higher" ? actual / expected : expected / actual;

    if (ratio >= 0.95) {
        cell.style.color = "green";
    } else if (ratio >= 0.85) {
        cell.style.color = "orange";
    } else {
        cell.style.color = "red";
    }
}






  function updateAllStats(results, pars, numPlayers) {
      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          updateStats(results, pars, numPlayers, playerIndex);
      }
  }

  function updateStats(results, pars, numPlayers, playerIndex) {
      const score = computeScore(pars.length, playerIndex);
      const points = computePoints(pars, playerIndex);

      for (let result of results) {
          updateResult(result, pars, playerIndex, score, points);

          // TEAM POINTS
          let pointsTeam = 0;
          for (let currPlayerIndex = 0; currPlayerIndex < numPlayers; currPlayerIndex++) {
              const playerPointsOrNaN = parseInt(
                  document.getElementById(idResultPointsPlayer(result.name, currPlayerIndex)).textContent
              );
              if (!isNaN(playerPointsOrNaN)) {
                  pointsTeam += playerPointsOrNaN;
              }
          }

          const teamPointsCell = document.getElementById(idResultPointsTeam(result.name));
          teamPointsCell.textContent = pointsTeam;

          // TEAM TARGET
          let teamTarget = 0;
          for (let currPlayerIndex = 0; currPlayerIndex < numPlayers; currPlayerIndex++) {
              const playerTarget = parseInt(document.getElementById(idTarget(currPlayerIndex)).value);
              if (!isNaN(playerTarget)) {
                  teamTarget += playerTarget;
              }
          }

          // Move these lines inside the loop where result is defined
          const holesPlayed = result.endExclusive - result.startInclusive;
          const expectedTeamPoints = (teamTarget / pars.length) * holesPlayed;

          // Apply color for team points
          applyPerformanceColor(teamPointsCell, pointsTeam, expectedTeamPoints, "higher");

          // TEAM NET
          let netTeam = 0;
          for (let currPlayerIndex = 0; currPlayerIndex < numPlayers; currPlayerIndex++) {
              const playerNetOrNaN = parseFloat(
                  document.getElementById(idResultNetPlayer(result.name, currPlayerIndex)).textContent
              );
              if (!isNaN(playerNetOrNaN)) {
                  netTeam += playerNetOrNaN;
              }
          }

          const netTeamCell = document.getElementById(idResultNetTeam(result.name));
          netTeamCell.textContent = netTeam;

          // Apply color for team net (goal is to stay close to 0 or positive)
          applyPerformanceColor(netTeamCell, netTeam, 0, "higher");
      }
  }

function updateResult(result, pars, playerIndex, score, points) {
    const holeIndices = Array.from(
        { length: result.endExclusive - result.startInclusive },
        (_, i) => result.startInclusive + i
    );

    const rawScores = score.scores;
    console.log(`Player ${playerIndex} - Raw Scores:`, rawScores);

    const playedHoles = holeIndices.filter(i => {
        const val = rawScores[i];
        return val !== "" && !isNaN(parseFloat(val));
    });

    console.log(`Hole Indices for result:`, holeIndices);
    console.log(`Played Holes in result range:`, playedHoles);

    const resultScore = sumNumbersByIndex(score.scores, holeIndices);
    const resultPoints = sumNumbersByIndex(points.points, holeIndices);

    const scoreCell = document.getElementById(idResultScorePlayer(result.name, playerIndex));
    const pointsCell = document.getElementById(idResultPointsPlayer(result.name, playerIndex));
    const netCell = document.getElementById(idResultNetPlayer(result.name, playerIndex));

    scoreCell.textContent = resultScore;
    pointsCell.textContent = resultPoints;

    const resultNet = computeNet(points, pars, holeIndices, playerIndex);
    netCell.textContent = resultNet;

    const targetPoints = parseInt(document.getElementById(idTarget(playerIndex)).value);
    const expectedPoints = (targetPoints / pars.length) * holeIndices.length;
    const expectedNet = 0;

    console.log(`Player ${playerIndex} - Points: ${resultPoints}, Expected Points: ${expectedPoints}`);
    console.log(`Player ${playerIndex} - Net: ${resultNet}, Expected Net: ${expectedNet}`);

    applyPerformanceColor(pointsCell, resultPoints, expectedPoints, "higher");
    applyPerformanceColor(netCell, resultNet, expectedNet, "higher");
}





  function computeScore(numHoles, playerIndex) {
      let scores = [];
      let total = 0;
      for (let holeIndex = 0; holeIndex < numHoles; holeIndex++) {
          const rawScore = document.getElementById(idHolePlayer(holeIndex, playerIndex)).value;
          scores.push(rawScore);

          const score = parseInt(rawScore);
          if (isNaN(score)) {
              continue;
          }
          total += score;
      }
      return { "overall_score": total, "scores": scores };
  }

  function computePoints(pars, playerIndex) {
      let scoresOrNaN = [];
      for (let holeIndex = 0; holeIndex < pars.length; holeIndex++) {
          scoresOrNaN.push(parseInt(document.getElementById(idHolePlayer(holeIndex, playerIndex)).value));
      }

      // We need to compute points iff the user has entered a value for the corresponding hole.

      let points = [];
      let total = 0;
      for (let holeIndex = 0; holeIndex < pars.length; holeIndex++) {
          if (isNaN(scoresOrNaN[holeIndex])) {
              points.push("");
              continue;
          }

          const point = Math.max(0, 2 - (scoresOrNaN[holeIndex] - pars[holeIndex]));
          points.push(point);
          total += point;
      }
      return { "overall_points": total, "points": points };
  }

  function computeNet(points, pars, holeIndices, playerIndex) {
    const targetOrNaN = parseInt(document.getElementById(idTarget(playerIndex)).value);

    if (isNaN(targetOrNaN)) {
        return "";
    }

    const resultTarget = targetOrNaN * (holeIndices.length / pars.length);
    const resultPoints = sumNumbersByIndex(points.points, holeIndices);
    const net = resultPoints - resultTarget;

    return Math.round(net * 10) / 10;
}


  function sumNumbersByIndex(numbersOrNaN, indices) {
      let out = 0;
      for (let index of indices) {
          const numOrNaN = parseInt(numbersOrNaN[index]);
          if (isNaN(numOrNaN)) {
              continue;
          }
          out += numOrNaN;
      }
      return out;
  }

  function updateTeamTarget(numPlayers) {
      let total = 0;
      for (let playerIndex = 0; playerIndex < numPlayers; playerIndex++) {
          const possibleTarget = parseInt(document.getElementById(idTarget(playerIndex)).value);
          if (isNaN(possibleTarget)) {
              continue;
          }
          total += possibleTarget;
      }

      document.getElementById("team_target").textContent = total;
  }


  function lockInputs() {
      const localSpreadsheetConfig = spreadsheetConfig();

      const submitButton = document.getElementById("submit_button");
      submitButton.disabled = true;

      const teamInput = document.getElementById("team");
      teamInput.disabled = true;

      // For now we hardcode that at most 4 players per team.
      for (let playerIndex = 0; playerIndex < 4; playerIndex++) {

          const possiblePlayerName = document.getElementById(idPlayerName(playerIndex));
          const possiblePlayerTarget = document.getElementById(idTarget(playerIndex));

          if (possiblePlayerName == null) {
              break;
          }

          possiblePlayerName.disabled = true;
          possiblePlayerTarget.disabled = true;

          for (let holeIndex = 0; holeIndex < localSpreadsheetConfig.courseConfig.pars.length; holeIndex++) {
              const possibleInput = document.getElementById(idHolePlayer(holeIndex, playerIndex));
              if (possibleInput == null) {
                  break;
              }
              possibleInput.disabled = true;
          }
      }

      // Set the lock flag to true
      inputsLocked = true;
      console.log("Inputs locked:", inputsLocked);
  }




  function submit() {
    clearInterval(saveInterval);

    const submitBtn = document.getElementById("submit_button");
    const originalText = submitBtn.textContent;
    submitBtn.classList.add("loading");
    submitBtn.textContent = "Submitting...";

    const localSpreadsheetConfig = spreadsheetConfig();
    const selectedTeamConfig = getSelectedTeamConfig(localSpreadsheetConfig.allTeamConfigs);
    const courseName = localSpreadsheetConfig.courseConfig.courseName;
    const pars = localSpreadsheetConfig.courseConfig.pars;
    const numHoles = pars.length;
    const currentTeamName = document.getElementById("team").value;
    const date = document.getElementById("date").textContent;

    let flatResults = [];
    let allScoresEntered = true;

    selectedTeamConfig.players.forEach((_, playerIndex) => {
      const playerNameEl = document.getElementById(idPlayerName(playerIndex));
      const playerName = playerNameEl.value;
      if (!playerName) return;

      const playerStats = [date, currentTeamName, courseName, playerName];
      for (let holeIndex = 0; holeIndex < numHoles; holeIndex++) {
        const score = document.getElementById(idHolePlayer(holeIndex, playerIndex)).value;
        playerStats.push(score);
        if (score === "") allScoresEntered = false;
      }
      playerStats.push(document.getElementById(idTarget(playerIndex)).value);
      for (const result of RESULTS) {
        playerStats.push(document.getElementById(idResultScorePlayer(result.name, playerIndex)).textContent);
        playerStats.push(document.getElementById(idResultPointsPlayer(result.name, playerIndex)).textContent);
        playerStats.push(document.getElementById(idResultNetPlayer(result.name, playerIndex)).textContent);
      }
      flatResults.push(playerStats);
    });

    const teamStats = [date, currentTeamName, courseName, currentTeamName];
    teamStats.push(...Array(numHoles).fill(""));
    teamStats.push(document.getElementById("team_target").textContent);
    for (const result of RESULTS) {
      teamStats.push("");
      teamStats.push(document.getElementById(idResultPointsTeam(result.name)).textContent);
      teamStats.push(document.getElementById(idResultNetTeam(result.name)).textContent);
    }
    flatResults.push(teamStats);

    let message =
      "Be sure all scores are correct! When so, click 'OK' to SUBMIT these scores.\n\n" +
      "Thanks!\n\n" +
      "A Green pop‚Äêup Submit & Email Success message indicates a successful submission.\n\n";
    if (!allScoresEntered) {
      message +=
        "Wait -- I see some holes without scores -- please 'Cancel' and fully fill in scores!\n\n";
    }
    message +=
      "With V. 5.0 and beyond, now each player will get an email of the submitted scorecard immediately upon a successful submission!";
    if (!confirm(message)) {
      submitBtn.classList.remove("loading");
      submitBtn.textContent = originalText;
      return;
    }

    google.script.run.recordScorerActivity({
      teamName: currentTeamName || "Unknown",
      playerName: scoreKeeper || "Unknown",
      activity: "Submitter"
    });

    const saveArray = selectedTeamConfig.players.map((_, playerIndex) => {
      const name = document.getElementById(idPlayerName(playerIndex)).value;
      const target = document.getElementById(idTarget(playerIndex)).value;
      const holeScores = [];
      for (let holeIndex = 0; holeIndex < numHoles; holeIndex++) {
        holeScores.push(document.getElementById(idHolePlayer(holeIndex, playerIndex)).value);
      }
      return [name, target, ...holeScores];
    });

    console.log("Saving before submitting:", JSON.stringify(saveArray));

    google.script.run
      .withSuccessHandler(() => {
        localStorage.setItem("savedScores", JSON.stringify(saveArray));
        const now = new Date();
        const time = now.getHours().toString() + ":" + now.getMinutes().toString().padStart(2, "0");
        document.getElementById("save_status").innerHTML = "<b><i>Saved at</i></b> " + time;
      })
      .withFailureHandler((error) => {
        const statusElem = document.getElementById("save_status");
        statusElem.textContent = "Failed to Save";
        statusElem.style.cssText = "font-size: 40px; font-weight: bold; color: red;";
        console.error("Error saving scores:", error);
      })
      .saveScoresForTeam(currentTeamName, saveArray);

    lockInputs();

    console.log("scoreKeeper being passed to server:", scoreKeeper);

    google.script.run
      .withSuccessHandler(function (serverLogs) {
        if (showServerLogs) {
          serverLogs.forEach((line) => console.log("Server:", line));
        }

        const teamKey = `autosaveDisabledDate_${currentTeamName}`;
        const today = new Date().toISOString().slice(0, 10);
        localStorage.setItem(teamKey, today);
        window.autoSaveManuallyDisabled = true;

        const autoSaveStatus = document.getElementById("autosave_status");
        if (autoSaveStatus) {
          autoSaveStatus.innerHTML = "<b>Auto-save disabled for today (scores already submitted)</b>";
          autoSaveStatus.style.color = "red";
        }

        console.log(`‚úÖ Submit successful ‚Äî autosaveDisabledDate set for ${currentTeamName}:`, today);
        console.log("autoSaveManuallyDisabled after submit:", window.autoSaveManuallyDisabled);

        const confirmEl = document.getElementById("submit_confirmation");
        confirmEl.textContent = "Submit & Email Success - Thanks!";
        confirmEl.style.cssText = "font-size: 40px; font-weight: bold; color: green;";
        const utterance = new SpeechSynthesisUtterance("Submit & Email Success - Thanks!");
        utterance.rate = 1.0;
        window.speechSynthesis.speak(utterance);

        forceLock = true;
        inputsLocked = true;

        document.querySelectorAll("input, select, button").forEach((el) => {
          if (el.id !== "refresh-btn") el.disabled = true;
        });

        const disableAndDim = (id) => {
          const btn = document.getElementById(id);
          if (btn) {
            btn.disabled = true;
            btn.style.opacity = "0.5";
          }
        };
        disableAndDim("submit_button");
        disableAndDim("clear_button");

        // ‚úÖ Reset button state
        submitBtn.classList.remove("loading");
        submitBtn.textContent = originalText;
      })
      .withFailureHandler((error) => {
        const confirmEl = document.getElementById("submit_confirmation");
        confirmEl.textContent = "Failed, re-start App, pull up your tee time, and re-submit.";
        confirmEl.style.cssText = "font-size: 40px; font-weight: bold; color: red;";
        const utterance = new SpeechSynthesisUtterance(confirmEl.textContent);
        utterance.rate = 1.0;
        window.speechSynthesis.speak(utterance);

        console.error("Submission failed:", error);

        // ‚ùå Reset button state on failure too
        submitBtn.classList.remove("loading");
        submitBtn.textContent = originalText;
      })
      .saveData(flatResults, scoreKeeper || "Unknown");
  }



  function clearWithConfirmation() {
      if (confirm("Be VERY sure you want to clear the hole scores!")) {
          clearScoresAndCache();
      }
  }


  function clearScoresAndCache() {
      const localSpreadsheetConfig = spreadsheetConfig();
      const selectedTeamConfig = getSelectedTeamConfig(localSpreadsheetConfig.allTeamConfigs);

      // For now we hardcode that at most 4 players per team.
      for (let playerIndex = 0; playerIndex < 4; playerIndex++) {
          for (let holeIndex = 0;
              holeIndex < localSpreadsheetConfig.courseConfig.pars.length;
              holeIndex++) {
              const possibleInput = document.getElementById(idHolePlayer(holeIndex, playerIndex));
              if (possibleInput == null) {
                  break;
                  }
                possibleInput.value = ""; // Set to empty string
                possibleInput.style.backgroundColor = "yellow"; // Set background color to yellow when empty
              }
      }

      localStorage.clear();

      // Basically just resets everything to empty
      updateAllStats(
          RESULTS,
          localSpreadsheetConfig.courseConfig.pars,
          selectedTeamConfig.players.length);
  }


  function clearScoresAndCacheForPlayer(playerIndex) {
    const localSpreadsheetConfig = spreadsheetConfig();
    const selectedTeamConfig = getSelectedTeamConfig(localSpreadsheetConfig.allTeamConfigs);

    for (let holeIndex = 0; holeIndex < localSpreadsheetConfig.courseConfig.pars.length; holeIndex++) {
      const possibleInput = document.getElementById(idHolePlayer(holeIndex, playerIndex));
      if (possibleInput == null) {
        break;
      }
      possibleInput.value = ""; // Set to empty string
      possibleInput.style.backgroundColor = "yellow"; // Set background color to yellow when empty
    }


    // Update stats for the remaining players
    updateAllStats(
      RESULTS,
      localSpreadsheetConfig.courseConfig.pars,
      selectedTeamConfig.players.length
    );
  }


  function idHoleRow(holeIndex) {
      return "holeRow_" + holeIndex;
  }

  function idHolePlayer(holeIndex, playerIndex) {
      return holeIndex + "_" + playerIndex;
  }

  function idResultScorePlayer(resultName, playerIndex) {
      return "result_" + resultName + "_score_" + playerIndex;
  }

  function idResultPointsPlayer(resultName, playerIndex) {
      return "result_" + resultName + "_points_" + playerIndex;
  }

  function idResultPointsTeam(resultName) {
      return "result_" + resultName + "_points_team";
  }

  function idPlayerName(playerIndex) {
      return "name_" + playerIndex;
  }

  function idTarget(playerIndex) {
      return "target_" + playerIndex;
  }

  function idResultNetPlayer(resultName, playerIndex) {
      return "result_" + resultName + "_net_" + playerIndex;
  }

  function idResultNetTeam(resultName) {
      return "result_" + resultName + "_net_team";
  }
 

   // Obfucation end - if desired

  </script>

</body>

</html>